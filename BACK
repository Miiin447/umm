import logging
import PIL
import pandas as pd
from datetime import datetime, timedelta
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import os
import sys
import re
import threading
import time
import random
import traceback
import shutil
import subprocess
from openpyxl.styles import Font, Alignment, Border, Side
from openpyxl import load_workbook
from openpyxl.utils import range_boundaries, get_column_letter
from copy import copy
from PIL import Image, ImageTk
import numpy as np
import psutil
import platform

# 디버그 정보 출력
print("=== 디버그 정보 ===")
print("Python 버전:", sys.version)
print("현재 작업 디렉토리:", os.getcwd())
print("sys.path:", sys.path)
print("필수 모듈 체크:")
try:
    print("- pandas:", pd.__version__)
except Exception as e:
    print("- pandas: 설치 필요 (", str(e), ")")
try:
    print("- openpyxl:", openpyxl.__version__)
except Exception as e:
    print("- openpyxl: 설치 필요 (", str(e), ")")
try:
    print("- PIL:", PIL.__version__)
except Exception as e:
    print("- PIL: 설치 필요 (", str(e), ")")

print("\n=== 파일 시스템 정보 ===")
try:
    print("현재 디렉토리 파일 목록:")
    for f in os.listdir('.'):
        print(f"- {f}")
except Exception as e:
    print("파일 목록 조회 실패:", str(e))

print("\n=== 시스템 정보 ===")
print("플랫폼:", sys.platform)
if hasattr(sys, 'getwindowsversion'):
    print("Windows 버전:", sys.getwindowsversion())

# Try to import chardet, with fallback to using utf-8 encoding
try:
    import chardet
    HAS_CHARDET = True
except ImportError:
    HAS_CHARDET = False
    print("Warning: chardet module not found. Using utf-8 as default encoding.")

# 예외 처리 개선
def custom_excepthook(type, value, tb):
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    # 콘솔에 출력
    print(f"\n=== 예외 발생 ({timestamp}) ===")
    print(f"예외 타입: {type}")
    print(f"예외 메시지: {value}")
    print("\n스택 트레이스:")
    traceback.print_tb(tb)
    print("\n상세 예외 정보:")
    trace_details = ''.join(traceback.format_exception(type, value, tb))
    print(trace_details)
    
    # 시스템 정보 수집
    system_info = f"""
시스템 정보:
- Python 버전: {sys.version}
- 운영체제: {platform.platform()}
- 메모리 상태: {psutil.virtual_memory() if 'psutil' in sys.modules else '정보 없음'}
- 현재 작업 디렉토리: {os.getcwd()}
- 실행 파일: {sys.argv[0]}
"""
    
    # 로그 파일에 기록
    try:
        log_dir = "logs"
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
        
        log_file = os.path.join(log_dir, f"error_log_{datetime.now().strftime('%Y%m%d')}.txt")
        with open(log_file, "a", encoding="utf-8") as f:
            f.write(f"\n\n=== 예외 발생 ({timestamp}) ===\n")
            f.write(f"예외 타입: {type}\n")
            f.write(f"예외 메시지: {value}\n\n")
            f.write("스택 트레이스:\n")
            f.write(trace_details)
            f.write("\n\n")
            f.write(system_info)
            f.write("\n===================================\n")
        
        print(f"상세 오류 로그가 {log_file}에 저장되었습니다.")
    except Exception as log_error:
        print(f"로그 파일에 오류 기록 실패: {str(log_error)}")

sys.excepthook = custom_excepthook

# Helper functions
def adjust_formula(formula, source_row, target_row):
    """Adjust formula by changing row reference"""
    if not formula or not isinstance(formula, str) or not formula.startswith('='):
        return formula
    
    # 정규식 패턴을 사용하여 수식 내의 셀 참조 업데이트
    pattern = re.compile(r"([A-Z]+)" + str(source_row))
    new_formula = pattern.sub(lambda m: m.group(1) + str(target_row), formula)
    return new_formula
    
def extract_korean_initials(text):
    """한글 이름에서 초성만 추출하는 함수, 영어 이름은 각 단어의 첫 글자만 대문자로 유지"""
    # 더 이상 초성 변환하지 않고 원본 값 그대로 반환
    return text

def standardize_value(val):
    """
    값을 표준화합니다. 날짜는 YYYY-MM-DD 형식으로, 텍스트는 소문자로 변환하고 특수문자를 제거합니다.
    """
    if val is None:
        return ""
    
    # 날짜 처리 시도
    try:
        dt = pd.to_datetime(val, errors='coerce')
        if pd.notnull(dt):
            return dt.strftime("%Y%m%d")
    except:
        pass
    
    # 텍스트 처리
    return re.sub(r'[^a-zA-Z0-9가-힣]', '', str(val).lower())

def standardize_date(date_value):
    """
    날짜를 YYYYMMDD 형식으로 표준화합니다.
    다양한 형식의 날짜를 처리할 수 있습니다.
    """
    if not date_value:
        return None
        
    try:
        # datetime 객체인 경우
        if isinstance(date_value, datetime):
            return date_value.strftime('%Y%m%d')
            
        # 문자열인 경우
        if isinstance(date_value, str):
            date_str = date_value.strip()
            
            # "2024년 3월 15일" 형식 처리
            if "년" in date_str and "월" in date_str and "일" in date_str:
                year = int(date_str.split("년")[0].strip())
                month = int(date_str.split("년")[1].split("월")[0].strip())
                day = int(date_str.split("월")[1].split("일")[0].strip())
                return f"{year:04d}{month:02d}{day:02d}"
            
            # "3월 15, 2024" 형식 처리
            if "월" in date_str and "," in date_str:
                month = int(date_str.split("월")[0].strip())
                day = int(date_str.split("월")[1].split(",")[0].strip())
                year = int(date_str.split(",")[1].strip())
                return f"{year:04d}{month:02d}{day:02d}"
            
            # 다른 형식의 날짜 처리
            dt = pd.to_datetime(date_str, errors='coerce')
            if pd.notnull(dt):
                return dt.strftime('%Y%m%d')
        
        return None
        
    except Exception as e:
        print(f"날짜 정규화 실패: {date_value} -> {str(e)}")
        return None

class ExcelProcessor:
    def __init__(self):
        """Initialize the Excel Processor"""
        # 로거 설정
        self.logger = logging.getLogger("ExcelProcessor")
        
        # PyInstaller 환경 확인
        self.is_frozen = getattr(sys, 'frozen', False)
        
        # 패키징된 환경에서는 NullHandler 추가
        if self.is_frozen:
            # 이미 파일 로깅이 활성화되어 있으므로 propagate만 True로 설정
            self.logger.propagate = True
        else:
            # 개발 환경에서는 일반 로깅 사용
            self.setup_logging()
        
        # 단순한 초기화 로그
        self.logger.info("Excel Processor 초기화 중...")
        
        # 설정 초기화
        self.main_file = None
        self.is_monitoring = False
        self.monitor_thread = None
        self.debug_visible = False
        self.last_saved_files = {}
        self.canceled = False
        
        # 시작 메시지
        self.logger.info("\n\n======== 프로그램 시작 ========")
        self.logger.info(f"Python 버전: {sys.version}")
        
        # 예외 핸들러 등록
        sys.excepthook = custom_excepthook
        
        # 여기서부터 시작 메시지 뒤에 기록
        self.logger.info("예외 처리 핸들러 등록 완료")
        
        # GUI 초기화
        self.setup_gui()
        
        # 기본적으로 처음에는 로그 레벨을 INFO로 설정 (디버그는 체크박스로 활성화)
        self.logger.setLevel(logging.INFO)
        
        # 디버그 모드 초기화 (프로그램 시작 시 이스터 에그 표시 - 5% 확률)
        if random.random() < 0.05:  # 5% 확률
            self.show_easter_egg()
        
        # 제외할 환자 및 의사명 목록 (클래스 변수로 정의)
        self.excluded_patients = {'TELE KDOC', 'NAM Hy'}
        self.excluded_doctors = {'Customer Support Center KDOC'}
    
    def show_easter_egg(self):
        try:
            # 이미지 파일 경로 설정 (절대 경로 사용)
            current_dir = os.path.abspath(os.path.dirname(__file__))
            image_paths = [
                os.path.join(current_dir, 'assets', 'yeah.png'),
                os.path.join(current_dir, 'assets', 'yeah2.png')
            ]
            
            # 랜덤하게 하나의 이미지 선택
            image_path = random.choice(image_paths)
            
            # 이미지 파일이 없으면 조용히 리턴
            if not os.path.exists(image_path):
                self.logger.debug(f"이스터에그 이미지 파일을 찾을 수 없습니다: {image_path}")
                return
                
            # 별도의 root window 생성
            easter_root = tk.Tk()
            easter_root.withdraw()  # 숨기기
            
            # 새 창 생성
            easter_window = tk.Toplevel(easter_root)
            easter_window.title("힘내!")
            
            try:
                # 이미지 로드 및 표시
                image = Image.open(image_path)
                image = image.resize((300, 300), Image.Resampling.LANCZOS)
                photo = ImageTk.PhotoImage(image, master=easter_window)  # master 지정
                
                # 이미지 라벨 생성
                label = tk.Label(easter_window, image=photo)
                label.image = photo  # 참조 유지
                label.pack()
                
            except Exception as img_error:
                self.logger.debug(f"이미지 로드 중 오류: {str(img_error)}")
                # 이미지 로드 실패 시 텍스트만 표시
                label = tk.Label(easter_window, text="힘내!", font=("Arial", 24))
                label.pack(pady=20)
            
            # 텍스트 추가
            text_label = tk.Label(easter_window, text="힘내!", font=("Arial", 16))
            text_label.pack(pady=10)
            
            # 창을 화면 중앙에 위치
            window_width = 320
            window_height = 380
            screen_width = easter_window.winfo_screenwidth()
            screen_height = easter_window.winfo_screenheight()
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2
            easter_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
            
            # 창 설정
            easter_window.lift()  # 창을 맨 앞으로
            easter_window.focus_force()  # 포커스 강제 지정
            
            # 5초 후 창 닫기
            def cleanup():
                try:
                    easter_window.destroy()
                    easter_root.destroy()
                except Exception as cleanup_error:
                    self.logger.debug(f"창 정리 중 오류: {str(cleanup_error)}")
                
            easter_window.after(5000, cleanup)
            
            # 이벤트 루프 시작 (non-blocking)
            easter_window.after(1, lambda: easter_root.mainloop())
            
        except Exception as e:
            self.logger.debug(f"이스터에그 이미지 표시 중 오류: {str(e)}")
            if 'easter_root' in locals():
                try:
                    easter_root.destroy()
                except:
                    pass
    
    def setup_logging(self):
        """Initialize logging system with minimal settings"""
        # 루트 로거의 핸들러가 없을 경우에만 초기화
        root_logger = logging.getLogger()
        if not root_logger.handlers:
            # 기존 핸들러 제거
            for handler in root_logger.handlers[:]:
                root_logger.removeHandler(handler)
                
            # 루트 로거 레벨 설정
            root_logger.setLevel(logging.INFO)  # 기본적으로 INFO 이상만 표시
            
            # 간소화된 포맷 설정
            simple_formatter = logging.Formatter(
                '[%(asctime)s] %(levelname)s: %(message)s',
                datefmt='%H:%M:%S'
            )
            
            # 콘솔 핸들러 추가
            console_handler = logging.StreamHandler()
            console_handler.setLevel(logging.INFO)
            console_handler.setFormatter(simple_formatter)
            root_logger.addHandler(console_handler)
            
        # 개별 로거 설정 (ExcelProcessor 로거)
        self.logger.setLevel(logging.INFO)  # 기본적으로 INFO 이상만 표시
        self.logger.propagate = True  # 루트 로거로 전파 허용
        
        print("로깅 시스템 초기화 완료")
        
    def setup_folders(self):
        """Create necessary folders if they don't exist"""
        folders = ['DONE', 'BACK UP', 'SKIPPED']
        for folder in folders:
            if not os.path.exists(folder):
                os.makedirs(folder)
                self.logger.info(f"{folder} 폴더 생성 완료")
                
    def setup_gui(self):
        self.root = tk.Tk()
        self.root.title("🌸 오리온 찬양해 🌸")
        
        # 기본 스타일 설정
        style = ttk.Style()
        self.root.configure(bg="#FFF8E1")  # 크림색 배경 (이전: #FFF0F5)
        
        # 창이 닫힐 때 정리 작업 수행
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        # GUI 구성 요소 생성
        self.create_gui_elements()
        
    def on_closing(self):
        """프로그램 종료 처리"""
        if messagebox.askokcancel("종료", "프로그램을 종료하시겠습니까?"):
            try:
                # 종료 메시지 출력
                self.logger.info("프로그램 종료")
                
                # stdout에 안전하게 출력 시도
                try:
                    if hasattr(sys, 'stdout') and sys.stdout and hasattr(sys.stdout, 'write'):
                        sys.stdout.write("프로그램이 종료됩니다.\n")
                        if hasattr(sys.stdout, 'flush'):
                            sys.stdout.flush()
                except Exception:
                    pass
                
                # 진행 표시줄 중지
                try:
                    if hasattr(self, 'progress_bar'):
                        self.progress_bar.stop()
                except Exception:
                    pass
                
                # 리디렉션 해제 - 안전하게 처리
                if hasattr(self, 'stdout_redirector'):
                    try:
                        if hasattr(self.stdout_redirector, 'original_stdout'):
                            sys.stdout = self.stdout_redirector.original_stdout
                    except Exception:
                        # 기본 출력으로 복원
                        sys.stdout = sys.__stdout__
                        
                if hasattr(self, 'stderr_redirector'):
                    try:
                        if hasattr(self.stderr_redirector, 'original_stdout'):
                            sys.stderr = self.stderr_redirector.original_stdout
                    except Exception:
                        # 기본 출력으로 복원
                        sys.stderr = sys.__stderr__
            except Exception as e:
                print(f"종료 중 오류 발생: {str(e)}")
            finally:
                # 즉시 강제 종료
                os._exit(0)
    
    def create_gui_elements(self):
        """Set up the GUI interface"""
        self.root.configure(bg="#FFF8E1")  # 크림색 배경 (이전: #FFF0F5)
        
        # Set up styles
        style = ttk.Style()
        style.theme_use("clam")
        
        # Define styles
        style.configure('Main.TFrame', background="#FFF8E1")
        style.configure('TLabel', background="#FFF8E1", foreground="#5D4037", font=('Malgun Gothic', 10))
        style.configure('Title.TLabel', font=('Malgun Gothic', 18, 'bold'), foreground="#EC407A", background="#FFF8E1")
        style.configure('Debug.TCheckbutton',
                       background="#FFF8E1",
                       foreground="#5D4037",
                       font=('Malgun Gothic', 10),
                       focuscolor='',
                       indicatorcolor='#FFBDBD')
        
        # Create the main paned window
        self.paned_window = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        self.paned_window.pack(fill=tk.BOTH, expand=True)
        
        # Main frame
        self.main_frame = ttk.Frame(self.paned_window, style='Main.TFrame', padding=10)
        
        # Debug frame (initially hidden)
        self.debug_frame = ttk.Frame(self.paned_window, style='Main.TFrame', padding=10)
        
        # Add the main frame to the paned window
        self.paned_window.add(self.main_frame, weight=1)
        
        # Create a title with cute stars
        title_label = ttk.Label(self.main_frame, text="✨ KDOC 마크7 V3.0 ✨", style='Title.TLabel')
        title_label.pack(pady=(20, 20))
        
        # 도움말 버튼 생성
        help_frame = tk.Frame(self.main_frame, bg="#8D6E63", padx=1, pady=1, bd=0)  # 갈색 (이전: #FF85A2)
        help_frame.place(relx=0.98, rely=0.02, anchor="ne")
        
        help_button = tk.Button(
            help_frame,
            text="?",
            font=("Arial", 12, "bold"),
            fg="#FFFFFF",
            bg="#8D6E63",  # 갈색 (이전: #FF85A2)
            relief="flat",
            cursor="hand2",
            command=self.show_help,
            width=1,
            padx=5
        )
        help_button.pack()
        
        # 원형 모양 만들기
        def make_circle():
            help_frame.update_idletasks()  # 위젯 크기 업데이트
            width = help_frame.winfo_width()
            height = help_frame.winfo_height()
            
            # 더 큰 값을 기준으로 원형 크기 설정
            size = max(width, height)
            
            # 원형으로 마스킹할 캔버스 생성
            canvas = tk.Canvas(self.main_frame, width=size, height=size, 
                            bg="#FFF8E1", highlightthickness=0)
            canvas.place(relx=0.95, rely=0.03, anchor="ne")
            
            # 원형 생성
            canvas.create_oval(0, 0, size, size, fill="#8D6E63", outline="#6D4C41", width=1)  # 갈색 (이전: #FF85A2)
            
            # 원형 중앙에 텍스트 배치
            canvas.create_text(size/2, size/2, text="?", fill="#FFFFFF", 
                            font=("Malgun Gothic", 12, "bold"))
            
            # 클릭 이벤트 연결
            canvas.bind("<Button-1>", lambda e: self.show_help())
            canvas.bind("<Enter>", lambda e: canvas.configure(cursor="hand2"))
        
        # UI 렌더링 후 원형 버튼 생성
        self.root.after(10, lambda: [help_frame.place_forget(), make_circle()])
        
        # 파일 상태 표시 프레임
        file_status_frame = tk.Frame(self.main_frame, bg="#FFF3E0", padx=15, pady=15, bd=1)  # 연한 크림색 (이전: #FFEFF5)
        file_status_frame.pack(fill=tk.X, pady=10)
        
        # 메인 파일 레이블
        self.main_file_label = tk.Label(
            file_status_frame,
            text="메인 파일: 파일 감지 필요",
            font=("Malgun Gothic", 10),
            bg="#FFF3E0",  # 연한 크림색 (이전: #FFEFF5)
            fg="#5D4037"
        )
        self.main_file_label.pack(anchor=tk.W, pady=2)
        
        self.patients_label = tk.Label(
            file_status_frame,
            text="Patients 파일: 파일 감지 필요",
            font=("Malgun Gothic", 10),
            bg="#FFF3E0",  # 연한 크림색 (이전: #FFEFF5)
            fg="#5D4037"
        )
        self.patients_label.pack(anchor=tk.W, pady=2)
        
        self.payment_label = tk.Label(
            file_status_frame,
            text="PaymentItems 파일: 파일 감지 필요",
            font=("Malgun Gothic", 10),
            bg="#FFF3E0",  # 연한 크림색 (이전: #FFEFF5)
            fg="#5D4037"
        )
        self.payment_label.pack(anchor=tk.W, pady=2)
        
        notice_label = tk.Label(
            file_status_frame, 
            text="🔍 처리할 파일은 프로그램과 같은 폴더에 위치해야 합니다.", 
            bg="#FFF3E0",  # 연한 크림색 (이전: #FFEFF5)
            fg="#9C6369", 
            font=("Malgun Gothic", 9, "italic")
        )
        notice_label.pack(anchor=tk.W, pady=(10, 2))
        
        # Create buttons frame
        buttons_frame = tk.Frame(self.main_frame, bg="#FFF8E1")
        buttons_frame.pack(fill=tk.X, pady=10)  # 패딩 줄임
        
        # Create buttons
        self.detect_button = tk.Button(
            file_status_frame,
            text="파일 감지",
            font=("Malgun Gothic", 10),
            bg="#F5CBA7",  # 황토색 (이전: 없음 또는 시스템 기본값)
            fg="#5D4037",
            relief="flat",
            cursor="hand2",
            command=lambda: threading.Thread(target=self.update_file_labels, args=(True,), daemon=True).start()
        )
        self.detect_button.pack(anchor=tk.W, pady=(10, 5))
        
        # 기능 버튼들은 처음에 비활성화 상태로 시작
        self.update_tables_btn = self.create_cute_button(buttons_frame, "표 업데이트", "📊", 
                                                        self.on_update_click, state=tk.DISABLED)
        
        self.update_patient_btn = self.create_cute_button(buttons_frame, "환자 정보 업데이트", "👤", 
                                                         self.on_patient_click, state=tk.DISABLED)
        
        self.exit_btn = self.create_cute_button(buttons_frame, "종료", "🚪", 
                                               self.on_exit_click)
        
        # 버튼 리스트 초기화
        self.buttons = [self.detect_button, self.update_tables_btn, self.update_patient_btn, self.exit_btn]
        
        # 상태 표시 레이블 및 진행 표시줄 생성
        status_frame = tk.Frame(self.main_frame, bg="#FFF8E1")
        status_frame.pack(fill=tk.X, pady=5)
        
        self.status_label = tk.Label(
            status_frame,
            text="파일 감지 중...",
            font=("Malgun Gothic", 9),
            bg="#FFF8E1",
            fg="black"
        )
        self.status_label.pack(side=tk.LEFT, padx=5)
        
        self.progress_bar = ttk.Progressbar(
            status_frame,
            mode="indeterminate",
            length=200
        )
        self.progress_bar.pack(side=tk.RIGHT, padx=5, fill=tk.X, expand=True)
        
        # Debug toggle - 귀여운 스타일로 변경
        debug_frame = tk.Frame(self.main_frame, bg="#FFF8E1")
        debug_frame.pack(fill=tk.X, pady=10, side=tk.BOTTOM)
        
        self.debug_var = tk.BooleanVar(value=False)
        
        # 귀여운 체크박스로 변경
        self.debug_check = tk.Checkbutton(
            debug_frame, 
            text="🐞 디버그 로그 보기", 
            variable=self.debug_var, 
            command=self.toggle_debug,
            bg="#FFF8E1",
            fg="#EC407A",
            font=("Malgun Gothic", 10),
            selectcolor="#FFD6E0",
            activebackground="#FFF8E1",
            relief="flat"
        )
        self.debug_check.pack(side=tk.LEFT)
        
        # 디버그 체크박스 옆에 도움말 표시 추가
        debug_help = tk.Label(
            debug_frame,
            text="(상세 로그 표시)",
            font=("Malgun Gothic", 8, "italic"),
            bg="#FFF8E1",
            fg="#888888"
        )
        debug_help.pack(side=tk.LEFT, padx=5)
        
        # Create log text widget inside debug frame with rounded corners
        self.log_text = tk.Text(
            self.debug_frame, 
            height=35,  # 높이 증가 (30 -> 35)
            width=140,  # 너비 증가 (120 -> 140)
            wrap=tk.WORD,
            font=('Consolas', 10),  # 고정폭 폰트 사용
            bg='#FFFFFF',  # 배경색 변경
            bd=1,
            relief="flat",
            padx=8,  # 내부 패딩 추가
            pady=8
        )
        
        # Create scrollbar for log text - 부모 컨테이너에 배치
        scrollbar = ttk.Scrollbar(self.debug_frame, command=self.log_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.log_text.config(yscrollcommand=scrollbar.set)
        
        # Create GUI log handler
        self.create_gui_log_handler()
        
        # 프로그램 버전 표시 - 귀여운 스타일
        version_label = tk.Label(
            self.main_frame,
            text="v3.0 💕",
            font=("Malgun Gothic", 8),
            fg="#EC407A",
            bg="#FFF8E1"
        )
        version_label.pack(side=tk.BOTTOM, anchor=tk.SE, padx=5, pady=5)
        
        # Set initial window size and position
        self.root.geometry("500x700")  # 높이 증가
        self.center_window()
        
        # 첫 실행시 파일 감지 수행
        self.update_file_labels()
    
    def create_cute_button(self, parent, text, emoji, command, state=tk.NORMAL):
        """Create a cute button with shadow effect"""
        # Shadow frame
        frame = tk.Frame(parent, bg="#D5A67E", padx=2, pady=2, bd=0)  # 그림자 색상 (이전: #FFBDBD)
        frame.pack(fill=tk.X, pady=5)  # 프레임 패킹 추가
        
        # Actual button
        button = tk.Button(
            frame,
            text=f"{emoji} {text}",
            font=("Malgun Gothic", 11),
            bg="#F5CBA7",  # 버튼 배경색 (이전: #FFE1E1)
            fg="#5D4037",
            relief="flat",
            cursor="hand2",
            command=command,
            state=state,
            activebackground="#E8D8C3"  # 클릭 시 배경색 (이전: #FFCCE5)
        )
        button.pack(fill=tk.X, ipady=5)  # 내부 패딩 줄임
        
        # 마우스 호버 이벤트
        button.bind("<Enter>", lambda e: self._on_button_hover(button, frame))
        button.bind("<Leave>", lambda e: self._on_button_leave(button, frame))
        
        return button
    
    def _on_button_hover(self, btn, frame):
        """Button hover effect"""
        btn.config(bg="#E8D8C3")  # 황토색 계열 (이전: #FFCCE5)
        frame.config(bg="#C8A382")  # 더 진한 갈색 (이전: #FF9EB5)
    
    def _on_button_leave(self, btn, frame):
        """Button leave effect"""
        btn.config(bg="#F5CBA7")  # 원래 색상 (이전: #FFE1E1)
        frame.config(bg="#D5A67E")  # 원래 그림자 색상 (이전: #FFBDBD)
    
    def toggle_debug(self):
        """디버그 모드 토글 (디버그 로그 창 표시/숨김)"""
        try:
            self.debug_visible = not self.debug_visible
            if self.debug_visible:
                # 디버그 모드 활성화
                logging.getLogger().setLevel(logging.DEBUG)
                self.logger.setLevel(logging.DEBUG)
                
                # 디버그 활성화 로그
                self.logger.debug("디버그 모드 활성화")
                
                # 패키징된 환경에서 로그를 콘솔에 출력 (GUI에는 표시 안 됨)
                if self.is_frozen:
                    print("디버그 모드 활성화")
                    self.logger.debug("패키징된 환경에서 디버그 모드를 활성화했습니다.")
                    self.logger.debug("로그는 'logs' 폴더에 저장됩니다.")
                    
                    # 메시지박스로 알림
                    messagebox.showinfo("디버그 모드", 
                        "디버그 모드가 활성화되었습니다.\n로그는 'logs' 폴더에 저장됩니다.")
                    return  # GUI 변경은 하지 않음
                
                # 디버그 프레임이 추가되어 있는지 확인
                try:
                    panes = self.paned_window.panes()
                    debug_frame_added = len(panes) > 1
                except:
                    debug_frame_added = False
                
                if not debug_frame_added:
                    # 디버그 프레임 추가
                    self.paned_window.add(self.debug_frame, weight=1)
                
                # 창 크기 조정
                self.root.geometry("1200x800")
                
                # 약간의 지연 후 패널 위치 조정
                self.root.after(100, self._adjust_sash_position)
            else:
                # 디버그 모드가 비활성화되면 로그 레벨을 INFO로 설정
                logging.getLogger().setLevel(logging.INFO)
                self.logger.setLevel(logging.INFO)
                self.logger.info("디버그 모드 비활성화")
                
                # 패키징된 환경인 경우
                if self.is_frozen:
                    print("디버그 모드 비활성화")
                    return  # GUI 변경은 하지 않음
                    
                # 디버그 프레임 제거
                try:
                    self.paned_window.forget(self.debug_frame)
                except:
                    pass
                
                # 창 크기 조정
                self.root.geometry("500x700")
        except Exception as e:
            # 에러 발생 시 로그 기록
            self.logger.error(f"디버그 창 토글 중 오류: {str(e)}")
        
        # 창 중앙 정렬
        self.center_window()
    
    def _adjust_sash_position(self):
        """패널 분할 위치 조정 (별도 메서드로 분리)"""
        try:
            pane_size = self.paned_window.winfo_width()
            if pane_size > 100:  # 충분한 너비가 있는 경우에만 조정
                self.paned_window.sashpos(0, int(pane_size * 0.3))
        except:
            pass
    
    def create_gui_log_handler(self):
        """로그 메시지를 GUI에 표시하기 위한 핸들러를 생성합니다"""
        # PyInstaller 환경인지 확인
        is_frozen = getattr(sys, 'frozen', False)
        
        # 패키징된 환경에서는 아무 작업도 하지 않음
        if is_frozen:
            return
        
        # 표준 출력과 표준 에러를 가로채기 위한 클래스 정의
        class StdoutRedirector:
            """표준 출력(stdout/stderr)을 GUI 텍스트 위젯으로 리디렉션하는 클래스"""
            def __init__(self, text_widget, level):
                self.text_widget = text_widget
                self.level = level  # 'INFO' 또는 'ERROR'
                self.buffer = ""
                self.prev_text = None
                self.dup_count = 0
                self.max_output = 500
                self.line_count = 0
                # 원래 표준 출력 저장
                self.original_stdout = getattr(sys, f'__{level.lower()}__', None)
                
            def write(self, string):
                """텍스트를 쓰고 GUI에 업데이트합니다"""
                if not string:  # 빈 문자열이면 무시
                    return
                    
                # 원래 stdout/stderr 출력 시도 - 안전장치 추가
                if not is_frozen:  # 패키징된 환경에서는 원본 스트림으로 출력하지 않음
                    try:
                        orig_stream = getattr(sys, f'__{self.level.lower()}__', None)
                        if orig_stream and hasattr(orig_stream, 'write'):
                            orig_stream.write(string)
                    except (AttributeError, IOError):
                        # 표준 출력이 사용 불가능한 경우 무시
                        pass
                
                # 텍스트 위젯이 없으면 여기서 종료
                if not self.text_widget:
                    return
                
                # 개행 문자만 있는 경우 버퍼 출력 후 종료
                if string == '\n' and self.buffer:
                    self._update_gui(self.buffer)
                    self.buffer = ""
                    return
                
                self.buffer += string
                
                # 완전한 라인이 있는지 확인
                if '\n' in self.buffer:
                    lines = self.buffer.split('\n')
                    # 마지막 라인은 완전하지 않을 수 있음
                    self.buffer = lines[-1]
                    
                    # 완전한 라인들을 GUI에 업데이트
                    for line in lines[:-1]:
                        if line:  # 빈 라인은 건너뜀
                            self._update_gui(line)
            
            def _update_gui(self, text):
                """GUI 텍스트 위젯에 텍스트를 업데이트합니다"""
                if not text.strip():  # 빈 텍스트는 무시
                    return
                
                try:
                    tag = 'INFO' if self.level == 'INFO' else 'ERROR'
                    self.text_widget.after(0, self._insert_text, text, tag)
                except Exception:
                    pass
                
            def _insert_text(self, text, tag):
                """텍스트 위젯에 텍스트를 삽입합니다"""
                try:
                    if not self.text_widget or not self.text_widget.winfo_exists():
                        return
                    
                    # 중복 메시지 검사
                    if text == self.prev_text:
                        self.dup_count += 1
                        self.text_widget.config(state=tk.NORMAL)
                        
                        # 마지막 줄 업데이트 시도
                        try:
                            last_line = self.text_widget.get("end-2l", "end-1c")
                            if last_line.startswith(text):
                                # 중복 카운트가 이미 있는지 확인
                                count_match = re.search(r'\((\d+)\)$', last_line)
                                if count_match:
                                    # 기존 카운트 업데이트
                                    old_count = count_match.group(1)
                                    self.text_widget.delete("end-" + str(len(old_count) + 3) + "c", "end-1c")
                                    self.text_widget.insert("end-1c", f"({self.dup_count})")
                                else:
                                    # 카운트 새로 추가
                                    self.text_widget.delete("end-2l", "end-1c")
                                    self.text_widget.insert("end", f"{text} ({self.dup_count})\n")
                            else:
                                # 마지막 줄이 현재 텍스트가 아니면 새 줄에 추가
                                self.text_widget.insert("end", f"{text} ({self.dup_count})\n")
                        except:
                            # 오류 발생 시 그냥 새 줄에 추가
                            self.text_widget.insert("end", f"{text} ({self.dup_count})\n")
                        
                        self.text_widget.see("end")
                        self.text_widget.config(state=tk.DISABLED)
                        return
                    
                    # 새 메시지
                    self.prev_text = text
                    self.dup_count = 1
                    
                    # 최대 라인 수 관리
                    if self.line_count > self.max_output:
                        self.text_widget.config(state=tk.NORMAL)
                        self.text_widget.delete("1.0", "10.0")
                        self.line_count -= 10
                    
                    self.text_widget.config(state=tk.NORMAL)
                    self.text_widget.insert("end", text + '\n', tag)
                    self.text_widget.see("end")
                    self.text_widget.config(state=tk.DISABLED)
                    self.line_count += 1
                except Exception:
                    pass
                    
            def flush(self):
                """출력 버퍼를 비웁니다"""
                if self.buffer:
                    self._update_gui(self.buffer)
                    self.buffer = ""
                
                # 원래 stdout/stderr도 플러시 시도
                if not is_frozen:
                    try:
                        orig_stream = getattr(sys, f'__{self.level.lower()}__', None)
                        if orig_stream and hasattr(orig_stream, 'flush'):
                            orig_stream.flush()
                    except (AttributeError, IOError):
                        pass
            
            def isatty(self):
                """터미널과 연결되어 있는지 확인합니다."""
                return False
        
        class GuiLogHandler(logging.Handler):
            """GUI에 로그를 출력하는 핸들러"""
            def __init__(self, app, text_widget):
                super().__init__()
                self.app = app
                self.text_widget = text_widget
                self.log_count = 0
                self.max_logs = 500
                # 위젯 유효성 플래그 추가
                self.is_valid = True
                
                # PyInstaller 환경 확인
                self.is_frozen = getattr(sys, 'frozen', False)
                
                # 로그 태그 설정 - 예외처리 추가
                try:
                    if self.text_widget and self.text_widget.winfo_exists():
                        self.text_widget.tag_configure("ERROR", foreground="red")
                        self.text_widget.tag_configure("WARNING", foreground="orange")
                        self.text_widget.tag_configure("INFO", foreground="blue")
                        self.text_widget.tag_configure("DEBUG", foreground="gray")
                except (tk.TclError, AttributeError, RuntimeError):
                    # 위젯 문제 발생 시 유효하지 않은 것으로 표시
                    self.is_valid = False
                    
                self.previous_message = None
                self.duplicate_count = 0
                
            def emit(self, record):
                """로그 레코드를 처리하여 GUI에 표시합니다."""
                # 패키징된 환경이면 로그를 최소화
                if self.is_frozen:
                    # 심각한 에러인 경우에만 처리
                    if record.levelno >= logging.ERROR:
                        try:
                            print(self.format(record))
                        except:
                            pass
                    return
                
                # 위젯이 유효하지 않으면 처리 중단
                if not self.is_valid:
                    return
                    
                try:
                    # 텍스트 위젯이 더 이상 존재하지 않으면 로그 처리 중단
                    if not self.text_widget:
                        self.is_valid = False
                        return
                        
                    # Tkinter 위젯 유효성 확인
                    try:
                        if not hasattr(self.text_widget, 'winfo_exists') or not self.text_widget.winfo_exists():
                            self.is_valid = False
                            return
                    except (tk.TclError, AttributeError, RuntimeError):
                        # Tkinter 관련 오류가 발생하면 위젯이 유효하지 않은 것으로 간주
                        self.is_valid = False
                        return
                    
                    # 로그 메시지 형식화
                    log_entry = self.format(record)
                    
                    # 중복 메시지 처리
                    if log_entry == self.previous_message:
                        self.duplicate_count += 1
                        try:
                            self.text_widget.config(state=tk.NORMAL)
                            # 마지막 줄에 중복 카운트 업데이트
                            try:
                                self.text_widget.delete(f"end-{len(str(self.duplicate_count-1)) + 3}c linestart", "end-1c lineend")
                                self.text_widget.insert("end-1c linestart", f"{log_entry} ({self.duplicate_count})")
                            except:
                                # 위 방식이 실패하면 그냥 새 줄에 추가
                                self.text_widget.insert("end", f"{log_entry} ({self.duplicate_count})\n")
                            self.text_widget.see("end")
                            self.text_widget.config(state=tk.DISABLED)
                        except tk.TclError:
                            # Tk 오류 발생 시 위젯이 유효하지 않음으로 표시
                            self.is_valid = False
                            return
                        return
                        
                    self.previous_message = log_entry
                    self.duplicate_count = 1
                    
                    # 최대 로그 개수 관리
                    if self.log_count >= self.max_logs:
                        try:
                            self.text_widget.config(state=tk.NORMAL)
                            self.text_widget.delete("1.0", "11.0")
                            self.text_widget.config(state=tk.DISABLED)
                            self.log_count -= 10
                        except tk.TclError:
                            # Tkinter 오류 발생 시 위젯이 유효하지 않음으로 표시
                            self.is_valid = False
                            return
                    
                    # 로그 삽입 (색상 태그 적용)
                    try:
                        tag = record.levelname  # 로그 레벨명을 태그로 사용
                        self.text_widget.config(state=tk.NORMAL)
                        self.text_widget.insert("end", log_entry + "\n", tag)
                        self.text_widget.see("end")  # 항상 마지막 로그가 보이도록 스크롤
                        self.text_widget.config(state=tk.DISABLED)
                        self.log_count += 1
                    except tk.TclError:
                        # Tk 오류 발생 시 위젯이 유효하지 않음으로 표시
                        self.is_valid = False
                        return
                    
                except Exception as e:
                    # 로그 처리 중 오류가 발생해도 졩용히 무시 (표준 에러로 출력)
                    try:
                        # 오류 발생 시 위젯을 유효하지 않은 것으로 표시
                        self.is_valid = False
                        sys.__stderr__.write(f"로그 처리 오류: {str(e)}\n")
                    except:
                        pass
            
            def close(self):
                """핸들러를 닫고 정리합니다."""
                self.is_valid = False  # 위젯이 유효하지 않음으로 표시
                super().close()
            
            def restore(self):
                """원래 stdout과 stderr로 복원합니다"""
                self.is_valid = False  # 위젯이 유효하지 않음으로 표시
                sys.stdout = sys.__stdout__
                sys.stderr = sys.__stderr__
        
        # 핸들러 생성 및 설정 (self 참조 전달)
        self.gui_log_handler = GuiLogHandler(self, self.log_text)
        
        # 디버그 로그 포맷터를 더 자세한 정보를 포함하도록 변경
        detailed_formatter = logging.Formatter(
            '[%(asctime)s] %(levelname)s: %(message)s',
            datefmt='%H:%M:%S'  # 시간 포맷 간소화
        )
        self.gui_log_handler.setFormatter(detailed_formatter)
        self.logger.addHandler(self.gui_log_handler)
        
        # 표준 출력과 표준 에러를 가로채서 GUI에도 표시
        self.stdout_redirector = StdoutRedirector(self.log_text, 'STDOUT')
        self.stderr_redirector = StdoutRedirector(self.log_text, 'STDERR')
        
        # 원본 스트림 저장
        self.stdout_redirector.original_stdout = sys.stdout
        self.stderr_redirector.original_stdout = sys.stderr
        
        # 스트림 리디렉션
        sys.stdout = self.stdout_redirector
        sys.stderr = self.stderr_redirector
        
        # 로그 시작 메시지
        self.logger.info("디버그 로그창 초기화 완료")
        print("터미널 출력이 디버그 로그창에도 표시됩니다.")
        
        # 자동으로 시스템 정보 및 디렉토리 정보 로깅 (디버그 모드에서만)
        if self.debug_visible:
            self.log_system_info()
            self.log_directory_contents()
        
        # Make log text read-only
        self.log_text.configure(state='disabled')
    
    def log_system_info(self):
        """시스템 정보를 로그에 기록"""
        self.logger.info("======== 시스템 정보 ========")
        self.logger.info(f"작업 디렉토리: {os.getcwd()}")
        self.logger.info(f"Python 버전: {sys.version.split()[0]}")
        self.logger.info(f"운영체제: {platform.system()} {platform.release()}")
        
        # 메모리 사용량 (psutil 라이브러리가 있는 경우)
        try:
            import psutil
            memory = psutil.virtual_memory()
            total_gb = memory.total / (1024 ** 3)
            available_gb = memory.available / (1024 ** 3)
            self.logger.info(f"메모리: 총 {total_gb:.1f}GB, 사용 가능 {available_gb:.1f}GB ({memory.percent}% 사용 중)")
        except ImportError:
            pass
            
        # 화면 정보
        try:
            width = self.root.winfo_screenwidth()
            height = self.root.winfo_screenheight()
            self.logger.info(f"화면 해상도: {width}x{height}")
        except:
            pass
            
        self.logger.info("==============================")
    
    def log_directory_contents(self):
        """현재 디렉토리의 파일 목록을 로그에 기록합니다."""
        try:
            # 디버그 정보 출력
            files = os.listdir()
            self.logger.info(f"현재 디렉토리 파일 목록 (총 {len(files)}개):")
            
            # 엑셀 및 CSV 파일만 로깅
            excel_files = [f for f in files if f.endswith(('.xlsx', '.csv'))]
            for file in excel_files:
                self.logger.info(f"  - {file}")
            
        except Exception as e:
            self.logger.error(f"디렉토리 내용 로깅 중 오류 발생: {e}")
            if self.debug_visible:
                traceback.print_exc()

    def update_file_labels(self, show_alert=False):
        """파일 상태 레이블을 업데이트합니다."""
        try:
            # 폴더 생성 확인
            self.setup_folders()
            
            # 파일 찾기 (print 내장)
            main_file = self.find_main_file()
            patients_file = self.find_file('patients')
            payment_items = self.find_file('paymentitems')
            
            # 중요 정보만 간략히 로깅 (INFO 레벨)
            file_summary = []
            if main_file:
                file_summary.append(f"메인: {main_file}")
            if patients_file:
                file_summary.append(f"Patients: {patients_file}")
            if payment_items:
                file_summary.append(f"PaymentItems: {payment_items}")
            
            if file_summary:
                print(f"파일 감지 결과: {', '.join(file_summary)}")
                
            # 레이블 업데이트
            self.main_file_label.config(text=f"메인 파일: {main_file if main_file else '없음'}")
            self.patients_label.config(text=f"Patients 파일: {patients_file if patients_file else '없음'}")
            self.payment_label.config(text=f"PaymentItems 파일: {payment_items if payment_items else '없음'}")
            
            # 상태 레이블 업데이트
            if not main_file:
                self.status_label.config(text="⚠️ 메인 파일 없음", fg="red")
            elif not patients_file and not payment_items:
                self.status_label.config(text="⚠️ 입력 파일 없음", fg="orange")
            else:
                self.status_label.config(text="준비 완료", fg="black")
            
            # 버튼 활성화/비활성화 설정
            if main_file:
                # 메인 파일만 있는 경우 환자 정보 업데이트 버튼 활성화
                self.update_patient_btn.config(state=tk.NORMAL, text="👤 환자 정보 업데이트")
                
                # 메인 파일과 Patients 또는 PaymentItems 파일이 있는 경우 표 업데이트 버튼 활성화
                if patients_file or payment_items:
                    self.update_tables_btn.config(state=tk.NORMAL, text="📊 표 업데이트")
                else:
                    self.update_tables_btn.config(state=tk.DISABLED, text="📊 표 업데이트")
                    self.logger.info("Patients/PaymentItems 파일 없음 - 표 업데이트 불가")
            else:
                # 메인 파일이 없는 경우 모든 기능 버튼 비활성화
                self.update_tables_btn.config(state=tk.DISABLED, text="📊 표 업데이트")
                self.update_patient_btn.config(state=tk.DISABLED, text="👤 환자 정보 업데이트")
                self.logger.info("메인 파일 없음 - 모든 기능 비활성화")

            if show_alert:
                # 간결한 메시지로 변경
                alert_message = "파일 상태:\n"
                if main_file:
                    alert_message += f"✅ 메인: {main_file}\n"
                else:
                    alert_message += "❌ 메인 파일 없음\n"
                    
                if patients_file:
                    alert_message += f"✅ Patients: {patients_file}\n"
                else:
                    alert_message += "❌ Patients 파일 없음\n"
                    
                if payment_items:
                    alert_message += f"✅ PaymentItems: {payment_items}"
                else:
                    alert_message += "❌ PaymentItems 파일 없음"
                    
                messagebox.showinfo("파일 감지 결과", alert_message)
        
        except Exception as e:
            self.logger.error(f"파일 감지 중 오류: {str(e)}")
            # 오류 발생 시 상세 로그 추가 (실제 디버깅에 필요한 정보)
            self.logger.error(traceback.format_exc())
    
    def normalize_date_format(self, date_value):
        """날짜를 표준화합니다."""
        return standardize_date(date_value)

    def normalize_text(self, text):
        """텍스트를 표준화합니다."""
        return standardize_value(text)

    def process_patients_file(self, main_file, patients_file):
        try:
            print(f"Patients 파일 처리 시작: {patients_file}")
            
            # 메인 파일과 Patients 파일 읽기
            wb = load_workbook(main_file)
            patients_df = self.read_csv_with_encoding(patients_file)
            
            if patients_df is None or patients_df.empty:
                print("Patients 파일이 비어있거나 읽을 수 없습니다.")
                return False
            
            # Patients 시트의 테이블 찾기
            patients_sheet = wb['Patients']
            table = self.find_table("환자자동", wb)
            if not table:
                print("Patients 시트의 테이블을 찾을 수 없습니다.")
                return False
            
            # 테이블 범위 파싱
            try:
                min_col, min_row, max_col, max_row = range_boundaries(table.ref)
                print(f"테이블 범위: min_col={min_col}, min_row={min_row}, max_col={max_col}, max_row={max_row}")
                
                # None 체크
                if None in (min_col, min_row, max_col, max_row):
                    print("테이블 범위가 올바르지 않습니다.")
                    return False
            except Exception as e:
                print(f"테이블 범위 파싱 오류: {str(e)}")
                # 강제로 시트 전체 범위 사용
                print("시트 전체 범위를 사용합니다.")
                min_col, min_row = 1, 1
                max_col = patients_sheet.max_column
                max_row = patients_sheet.max_row
            
            # 헤더 매핑 생성
            excel_headers = {}
            csv_headers = list(patients_df.columns)
            
            # 열 이름과 열 인덱스 매핑
            col_to_letter = {}
            
            for col in range(min_col, max_col + 1):
                cell_value = patients_sheet.cell(row=min_row, column=col).value
                if cell_value:
                    header_name = str(cell_value).strip()
                    excel_headers[header_name] = col
                    col_to_letter[header_name] = get_column_letter(col)
                    
            # 중복 데이터 체크를 위한 컬럼 찾기
            name_col = excel_headers.get("이름")
            email_col = excel_headers.get("이메일")
            dob_col = excel_headers.get("생년월일")
            
            # 생년월일 컬럼이 없으면 생년 컬럼을 찾습니다
            if dob_col is None:
                dob_col = excel_headers.get("생년")
                self.logger.info("생년월일 컬럼이 없어 생년 컬럼을 사용합니다.")
            
            # 열 매핑 특별 처리: 나이를 Age로 취급
            age_col = excel_headers.get("Age") or excel_headers.get("나이")
            age_range_col = excel_headers.get("Age_Range")
            reg_date_col = excel_headers.get("등록 날짜")
            birth_date_col = dob_col  # 생년월일 또는 생년 컬럼
            
            # 현재 있는 주 컬럼 찾기 - 디버깅 개선
            state_col = excel_headers.get("현재 있는 주")
            
            # 컬럼 찾기 상세 로깅
            self.logger.info(f"엑셀 헤더 전체 목록: {excel_headers}")
            self.logger.info(f"이름 열: {name_col}")
            self.logger.info(f"등록 날짜 열: {reg_date_col}")
            self.logger.info(f"현재 있는 주 열: {state_col}")
            
            # 중복 체크 컬럼 확인
            if reg_date_col is None:
                self.logger.warning("'등록 날짜' 컬럼을 찾을 수 없습니다. 중복 체크에서 이 항목은 무시됩니다.")
            
            if state_col is None:
                self.logger.warning("'현재 있는 주' 컬럼을 찾을 수 없습니다. 중복 체크에서 이 항목은 무시됩니다.")
            
            # 중요 컬럼 로깅
            self.logger.debug(f"이름 열: {name_col} ({col_to_letter.get('이름', '?')})")
            self.logger.debug(f"Age/나이 열: {age_col} ({col_to_letter.get('나이', '?')})")
            self.logger.debug(f"Age_Range 열: {age_range_col} ({col_to_letter.get('Age_Range', '?')})")
            self.logger.debug(f"등록 날짜 열: {reg_date_col} ({col_to_letter.get('등록 날짜', '?')})")
            self.logger.debug(f"현재 있는 주 열: {state_col} ({col_to_letter.get('현재 있는 주', '?')})")
            
            # 생년월일 또는 생년 컬럼 로깅
            if "생년월일" in excel_headers:
                self.logger.debug(f"생년월일 열: {birth_date_col} ({col_to_letter.get('생년월일', '?')})")
            else:
                self.logger.debug(f"생년 열: {birth_date_col} ({col_to_letter.get('생년', '?')})")
                
            # 도시 컬럼 로깅 (필수 아님)
            city_col = excel_headers.get("도시")
            if city_col:
                self.logger.debug(f"도시 열: {city_col} ({col_to_letter.get('도시', '?')})")
                
            # 이메일 컬럼 로깅 (필수 아님)
            if email_col:
                self.logger.debug(f"이메일 열: {email_col} ({col_to_letter.get('이메일', '?')})")
            
            # 이메일과 도시는 필수가 아님, 이름과 생년(월일)만 필수로 체크
            if not all([name_col, birth_date_col]):
                if "생년월일" in excel_headers:
                    self.logger.error(f"필수 컬럼을 찾을 수 없습니다. 이름: {name_col}, 생년월일: {birth_date_col}")
                else:
                    self.logger.error(f"필수 컬럼을 찾을 수 없습니다. 이름: {name_col}, 생년: {birth_date_col}")
                return False
            
            # 참조할 공식 및 스타일이 있는 행 찾기
            formula_row = None
            for row in range(min_row + 1, max_row + 1):
                # Age_Range 또는 Age 열에 공식이 있는지 확인
                try:
                    if age_range_col and patients_sheet.cell(row=row, column=age_range_col).value and str(patients_sheet.cell(row=row, column=age_range_col).value).startswith('='):
                        formula_row = row
                        self.logger.debug(f"Age_Range 공식이 있는 행 발견: {row}")
                        break
                    elif age_col and patients_sheet.cell(row=row, column=age_col).value and str(patients_sheet.cell(row=row, column=age_col).value).startswith('='):
                        formula_row = row
                        self.logger.debug(f"Age 공식이 있는 행 발견: {row}")
                        break
                except:
                    continue
            
            # 기존 공식 추출 부분 제거
            birth_col_letter = col_to_letter.get("생년", col_to_letter.get("생년월일", "E"))  # 생년 또는 생년월일 컬럼 문자 가져오기
            
            # 생년월일로부터 나이 계산 공식 - 생년이 있는 경우 직접 계산
            if "생년" in excel_headers:
                age_formula_template = f'=YEAR(TODAY())-{birth_col_letter}{{row}}'
            else:
                age_formula_template = f'=DATEDIF(DATE(RIGHT({birth_col_letter}{{row}},4),MONTH(1&LEFT({birth_col_letter}{{row}},FIND("월",{birth_col_letter}{{row}})-1)),MID({birth_col_letter}{{row}},FIND("월",{birth_col_letter}{{row}})+2,FIND(",",{birth_col_letter}{{row}})-FIND("월",{birth_col_letter}{{row}})-2)),TODAY(),"Y")'
            
            age_range_formula_template = f'=LOOKUP({col_to_letter.get("나이", "D")}{{row}},{{0,20,30,40,50,60,70}},{{"10s","20s","30s","40s","50s","60s","70s+"}})'
            
            # 새 데이터 추가 위치 찾기 (병합 셀 고려)
            next_row = max_row + 1  # 일단 기본값으로 설정
            try:
                next_row = self.find_safe_row(patients_sheet, max_row + 1, min_col, max_col)
            except Exception as e:
                self.logger.error(f"안전한 행 찾기 오류: {str(e)}")
                # 오류 발생 시 기본값 유지
            
            # 데이터 추가
            added_count = 0
            skipped_count = 0
            
            # 중복 체크를 위한 기존 데이터 수집
            existing_records = {}  # 키: (이름, 날짜, 주) 또는 (이름, 날짜)
            existing_names = {}    # 키: 이름, 값: 행 번호 리스트
            self.logger.info("\n=== 기존 데이터 수집 시작 ===")
            
            # 엑셀 파일의 기존 데이터 수집
            for excel_row in range(min_row + 1, max_row + 1):
                try:
                    # 이름 정규화
                    name = patients_sheet.cell(row=excel_row, column=name_col).value
                    if not name:
                        continue
                    name = self.normalize_text(name)
                    
                    # 등록 날짜 정규화
                    reg_date = None
                    if reg_date_col is not None:
                        reg_date_cell = patients_sheet.cell(row=excel_row, column=reg_date_col)
                        if reg_date_cell and reg_date_cell.value:
                            reg_date = self.normalize_date_format(reg_date_cell.value)
                    
                    # 현재 있는 주 정규화
                    state = None
                    if state_col is not None:
                        state_cell = patients_sheet.cell(row=excel_row, column=state_col)
                        if state_cell and state_cell.value:
                            state = self.normalize_text(state_cell.value)
                    
                    # 중복 체크를 위한 키 생성
                    # 현재 있는 주가 공란이면 이름과 등록 날짜만으로 키 생성
                    if not state:
                        key = (name, reg_date if reg_date is not None else "")
                        self.logger.info(f"주 정보 없음 - 이름과 등록 날짜만으로 중복 체크 키 생성: {key}")
                    else:
                        key = (name, reg_date if reg_date is not None else "", state)
                        
                    existing_records[key] = excel_row
                    
                    # 이름만으로 구성된 키도 별도로 저장 (완전히 다른 딕셔너리에 저장)
                    if name not in existing_names:
                        existing_names[name] = []
                    existing_names[name].append(excel_row)
                    
                    self.logger.info(f"기존 레코드 수집 (행 {excel_row}):\n  이름: {name}\n  등록날짜: {reg_date}\n  현재있는주: {state}")
                    
                except Exception as e:
                    self.logger.warning(f"기존 데이터 수집 중 오류 (행 {excel_row}): {str(e)}")
                    continue

            self.logger.info(f"\n=== 수집된 기존 레코드 수: {len(existing_records)} ===")
            self.logger.info("=== 수집된 기존 레코드 목록 ===")
            for key, row in existing_records.items():
                self.logger.info(f"행 {row}: {key}")

            # CSV 데이터 처리
            self.logger.info("\n=== CSV 데이터 처리 시작 ===")
            for idx, row in patients_df.iterrows():
                try:
                    # 이름 정규화
                    name = row.get("이름", "")
                    if not name:
                        skipped_count += 1
                        self.logger.warning("이름이 없는 레코드 건너뛰기")
                        continue
                    name = self.normalize_text(name)
                    
                    # 등록 날짜 정규화
                    reg_date = self.normalize_date_format(row.get("등록 날짜"))
                    
                    # 현재 있는 주 정규화
                    state = self.normalize_text(row.get("현재 있는 주", ""))
                    
                    # 중복 체크
                    # 현재 있는 주가 공란이면 이름과 등록 날짜만으로 키 생성
                    if not state:
                        key = (name, reg_date if reg_date is not None else "")
                        self.logger.info(f"주 정보 없음 - 이름과 등록 날짜만으로 중복 체크: {key}")
                    else:
                        key = (name, reg_date if reg_date is not None else "", state)
                        
                    self.logger.info(f"\n검사할 레코드 (행 {idx + 2}):\n  이름: {name}\n  등록날짜: {reg_date}\n  현재있는주: {state}")
                    self.logger.info(f"중복 체크 키: {key}")
                    
                    # 중복 키 검사 - 3단계로 확인
                    is_duplicate = False
                    existing_row = None
                    duplicate_type = ""
                    
                    # 1단계: 정확한 키 일치 여부 확인 (이름+등록날짜+현재있는주 또는 이름+등록날짜)
                    if key in existing_records:
                        is_duplicate = True
                        existing_row = existing_records[key]
                        duplicate_type = "완전 일치"
                    
                    # 2단계: 이름과 날짜만으로 중복 확인 (모든 주 정보가 있는 경우의 추가 검사)
                    elif len(key) == 3 and not is_duplicate:
                        short_key = (name, reg_date if reg_date is not None else "")
                        for exist_key, exist_row in existing_records.items():
                            # 이름과 등록날짜가 동일하고, 주 정보는 하나라도 있는 경우 (주 정보는 다를 수 있음)
                            if isinstance(exist_key, tuple) and len(exist_key) > 1:
                                exist_name = exist_key[0] if exist_key[0] else ""
                                exist_date = exist_key[1] if len(exist_key) > 1 and exist_key[1] else ""
                                
                                if exist_name == name and exist_date == reg_date:
                                    is_duplicate = True
                                    existing_row = exist_row
                                    duplicate_type = "이름, 날짜 일치 (주 다름)"
                                    break
                    
                    # 3단계: 이름이 같고 등록 날짜가 같은 레코드가 있는지 확인 (추가 검사)
                    if not is_duplicate and name in existing_names:
                        for row_num in existing_names[name]:
                            # 등록 날짜 비교
                            excel_date = None
                            if reg_date_col is not None:
                                date_cell = patients_sheet.cell(row=row_num, column=reg_date_col)
                                if date_cell and date_cell.value:
                                    excel_date = self.normalize_date_format(date_cell.value)
                            
                            # 두 날짜가 비슷한지 확인 (둘 다 있고 같은 경우)
                            if reg_date and excel_date and reg_date == excel_date:
                                is_duplicate = True
                                existing_row = row_num
                                duplicate_type = "이름, 날짜 일치 (3단계 확인)"
                                break
                    
                    if is_duplicate:
                        # 중복 레코드의 상세 정보 가져오기
                        excel_name = patients_sheet.cell(row=existing_row, column=name_col).value if name_col else "N/A"
                        excel_date = patients_sheet.cell(row=existing_row, column=reg_date_col).value if reg_date_col is not None else "N/A"
                        excel_state = patients_sheet.cell(row=existing_row, column=state_col).value if state_col is not None else "N/A"
                        
                        self.logger.info(
                            f">>> 중복 발견 <<< ({duplicate_type})\n"
                            f"CSV 데이터 (행 {idx + 2}):\n"
                            f"  - 이름: {name}\n"
                            f"  - 등록날짜: {reg_date}\n"
                            f"  - 현재있는주: {state}\n"
                            f"엑셀 데이터 (행 {existing_row}):\n"
                            f"  - 이름: {excel_name}\n"
                            f"  - 등록날짜: {excel_date}\n"
                            f"  - 현재있는주: {excel_state}"
                        )
                        skipped_count += 1
                        continue
                    else:
                        self.logger.info(">>> 새로운 레코드 - 추가 진행 <<<")
                    
                    # 중복이 아닌 경우 existing_records에 추가
                    existing_records[key] = next_row
                    # 이름별 인덱스에도 추가
                    if name not in existing_names:
                        existing_names[name] = []
                    existing_names[name].append(next_row)
                    
                except Exception as e:
                    self.logger.warning(f"중복 체크 중 오류: {str(e)}")
                    skipped_count += 1
                    continue

                # 각 엑셀 컬럼에 데이터 추가
                for excel_header, col_index in excel_headers.items():
                    try:
                        cell = patients_sheet.cell(row=next_row, column=col_index)
                        
                        # CSV 헤더에 해당하는 값이 있는 경우 추가
                        csv_value = None
                        if excel_header in csv_headers:
                            csv_value = row.get(excel_header)
                        
                        # 데이터 추가
                        if excel_header == "Age" or excel_header == "나이":
                            # 생년월일 값이 있는 경우에도 공식 사용하지 않고 빈 값으로 설정
                            cell.value = None  # 공식 대신 공란으로 설정
                        elif excel_header == "Age_Range":
                            # 생년월일 값이 있는 경우에도 공식 사용하지 않고 빈 값으로 설정
                            cell.value = None  # 공식 대신 공란으로 설정
                        elif excel_header == "등록 날짜" and csv_value is not None:
                            # 등록 날짜 형식 변경
                            try:
                                # "3월 29, 20"과 같은 형식 처리
                                if isinstance(csv_value, str) and '월' in csv_value and ',' in csv_value:
                                    month_str = csv_value.split('월')[0].strip()
                                    day_str = csv_value.split('월')[1].split(',')[0].strip()
                                    year_str = csv_value.split(',')[1].strip()
                                    
                                    # 두 자리 년도를 네 자리로 변환 (20 -> 2020)
                                    if len(year_str) == 2:
                                        year_str = '20' + year_str
                                    
                                    # 날짜 객체 생성
                                    month = int(month_str)
                                    day = int(day_str)
                                    year = int(year_str)
                                    dt = datetime(year, month, day)
                                    cell.value = f"{dt.year}년 {dt.month}월 {dt.day}일"
                                else:
                                    dt = pd.to_datetime(csv_value, errors='coerce')
                                    if pd.notnull(dt):
                                        cell.value = dt.strftime("%Y년 %m월 %d일")
                                    else:
                                        cell.value = csv_value
                            except Exception as e:
                                self.logger.warning(f"등록 날짜 형식 변환 실패: {csv_value} -> {str(e)}")
                                cell.value = csv_value
                        elif excel_header == "생년" and "생년월일" in row:
                            # CSV에서는 "생년월일" 컬럼이고 엑셀에서는 "생년" 컬럼인 경우
                            birth_date_value = row.get("생년월일")
                            if birth_date_value:
                                try:
                                    if isinstance(birth_date_value, datetime):
                                        cell.value = birth_date_value.year
                                    elif isinstance(birth_date_value, str):
                                        # 다양한 형식 처리
                                        date_patterns = [
                                            r'(\d{4})[/\-\.](0?[1-9]|1[0-2])[/\-\.](0?[1-9]|[12][0-9]|3[01])',  # YYYY/MM/DD
                                            r'(0?[1-9]|1[0-2])[/\-\.](0?[1-9]|[12][0-9]|3[01])[/\-\.](\d{4})',  # MM/DD/YYYY
                                            r'(0?[1-9]|[12][0-9]|3[01])[/\-\.](0?[1-9]|1[0-2])[/\-\.](\d{4})',  # DD/MM/YYYY
                                            r'(\d{4})년\s*(0?[1-9]|1[0-2])월\s*(0?[1-9]|[12][0-9]|3[01])일',     # YYYY년 MM월 DD일
                                            r'(\d{4})',  # 연도만 (YYYY)
                                            r'(?:0?[1-9]|1[0-2])월\s*(?:0?[1-9]|[12][0-9]|3[01]),\s*(\d{4})'  # MM월 DD, YYYY
                                        ]
                                        
                                        for pattern in date_patterns:
                                            match = re.search(pattern, birth_date_value)
                                            if match:
                                                if '년' in pattern:  # 한국식
                                                    cell.value = int(match.group(1))
                                                elif pattern == r'(\d{4})':  # 연도만
                                                    cell.value = int(match.group(1))
                                                elif pattern.endswith(r'(\d{4})'):  # MM월 DD, YYYY
                                                    cell.value = int(match.group(1))
                                                elif '/' in pattern or '-' in pattern or '.' in pattern:
                                                    # 패턴에 따라 연도 위치가 다를 수 있음
                                                    if pattern.startswith(r'(\d{4})'):  # YYYY/MM/DD
                                                        cell.value = int(match.group(1))
                                                    else:  # MM/DD/YYYY 또는 DD/MM/YYYY
                                                        cell.value = int(match.group(3))
                                                break
                                        
                                        if cell.value is None:
                                            # 패턴 매칭 실패 시 datetime 변환 시도
                                            dt = pd.to_datetime(birth_date_value, errors='coerce')
                                            if pd.notnull(dt):
                                                cell.value = dt.year
                                            else:
                                                cell.value = birth_date_value  # 원래 값 그대로 유지
                                except Exception as e:
                                    self.logger.warning(f"생년월일에서 연도 추출 실패: {birth_date_value} -> {str(e)}")
                                    cell.value = birth_date_value
                        elif excel_header == "이름" and csv_value is not None:
                            # 이름은 초성만 저장 (수정: 이제 원래 이름 그대로 사용)
                            cell.value = csv_value
                            self.logger.debug(f"이름 그대로 사용: {csv_value}")
                        elif csv_value is not None:
                            cell.value = csv_value
                        
                        # 셀 스타일 복사 (첫 번째 데이터 행이 아닌 경우에만)
                        if next_row > min_row + 1:
                            try:
                                source_cell = patients_sheet.cell(row=min_row + 1, column=col_index)
                                self.copy_cell_style(source_cell, cell)
                            except Exception as e:
                                self.logger.warning(f"셀 스타일 복사 오류: {str(e)}")
                    except Exception as e:
                        self.logger.warning(f"셀 {excel_header} 업데이트 중 오류 발생: {str(e)}")
                        traceback.print_exc()
                
                # 등록 날짜가 제대로 들어갔는지 확인하고, Age와 Age_Range가 공식을 사용하는지 확인
                self.logger.debug(f"등록 날짜 값: {patients_sheet.cell(row=next_row, column=reg_date_col).value}")
                
                # 생년월일 또는 생년 값 로깅
                if "생년월일" in excel_headers:
                    self.logger.debug(f"생년월일 값: {patients_sheet.cell(row=next_row, column=birth_date_col).value}")
                else:
                    self.logger.debug(f"생년 값: {patients_sheet.cell(row=next_row, column=birth_date_col).value}")
                
                if age_col:
                    self.logger.debug(f"Age 값: {patients_sheet.cell(row=next_row, column=age_col).value}")
                if age_range_col:
                    self.logger.debug(f"Age_Range 값: {patients_sheet.cell(row=next_row, column=age_range_col).value}")
                
                next_row += 1
                added_count += 1
            
            # 테이블 범위 확장
            if added_count > 0:
                try:
                    table.ref = f"{get_column_letter(min_col)}{min_row}:{get_column_letter(max_col)}{next_row-1}"
                except Exception as e:
                    self.logger.error(f"테이블 범위 확장 오류: {str(e)}")
            
            # 파일 저장
            wb.save(main_file)
            
            # 결과 처리
            if skipped_count == len(patients_df):
                self.logger.warning(f"모든 내용이 중복된 파일: {patients_file}")
                
                # 중복된 레코드들의 상세 정보 수집
                duplicate_details = []
                for _, row in patients_df.iterrows():
                    name = row.get('이름', '')
                    reg_date = self.normalize_date_format(row.get('등록 날짜', ''))
                    state = row.get('현재 있는 주', '')
                    duplicate_details.append(f"▶ 중복 레코드\n  - 이름: {name}\n  - 등록 날짜: {reg_date}\n  - 현재 있는 주: {state}\n")
                
                details = (
                    f"파일명: {patients_file}\n"
                    f"총 레코드 수: {len(patients_df)}개\n"
                    f"중복 레코드 수: {skipped_count}개\n\n"
                    f"=== 중복된 레코드 목록 ===\n\n"
                    + "\n".join(duplicate_details)
                )
                
                self.show_detailed_result(
                    "중복 파일",
                    "모든 내용이 중복된 파일입니다.\n이 파일은 SKIPPED 폴더로 이동됩니다.",
                    details
                )
                target_folder = "SKIPPED"
            else:
                self.logger.info(f"Patients 파일 처리 완료: 추가 {added_count}건, 중복 {skipped_count}건")
                
                # 중복된 레코드들의 상세 정보 수집
                duplicate_details = []
                skipped_records = []  # 중복으로 건너뛴 레코드 정보 저장
                for _, row in patients_df.iterrows():
                    name = row.get('이름', '')
                    reg_date = self.normalize_date_format(row.get('등록 날짜', ''))
                    state = row.get('현재 있는 주', '')
                    key = (name, reg_date, state)
                    if key in existing_records:
                        skipped_records.append(f"▶ 중복 레코드\n  - 이름: {name}\n  - 등록 날짜: {reg_date}\n  - 현재 있는 주: {state}\n")
                
                details = (
                    f"처리된 파일: {patients_file}\n\n"
                    f"▶ 처리 결과\n"
                    f"- 총 레코드 수: {len(patients_df)}개\n"
                    f"- 성공적으로 추가된 레코드: {added_count}개\n"
                    f"- 중복으로 건너뛴 레코드: {skipped_count}개\n\n"
                    f"▶ 테이블 정보\n"
                    f"- 시작 행: {min_row}\n"
                    f"- 종료 행: {next_row-1}\n"
                    f"- 처리된 컬럼: {', '.join(excel_headers.keys())}\n\n"
                )
                
                if skipped_records:
                    details += f"=== 중복으로 건너뛴 레코드 목록 ===\n\n" + "\n".join(skipped_records)
                
                details += "\n파일은 DONE 폴더로 이동되었습니다."
                
                self.show_detailed_result(
                    "처리 완료",
                    f"Patients 파일 처리가 완료되었습니다.\n추가: {added_count}건, 중복: {skipped_count}건",
                    details
                )
                target_folder = "DONE"
            
            # 파일 이동
            target_file = os.path.join(target_folder, os.path.basename(patients_file))
            shutil.move(patients_file, target_file)
            
            return True
            
        except Exception as e:
            self.logger.error(f"Patients 파일 처리 중 오류 발생: {str(e)}")
            traceback.print_exc()  # 상세 오류 정보 출력
            return False
    
    def process_payment_items(self, main_file, payment_file):
        """Process payment items and update the customer management table"""
        try:
            self.logger.info(f"PaymentItems 파일 처리 시작: {payment_file}")
            
            # 변수 초기화
            skipped_count = 0  # 중복으로 건너뛴 항목 수
            exception_count = 0  # 예외 사항 수
            processed_count = 0
            # 중복 레코드 정보 저장 리스트 추가
            skipped_records = []  # 중복 레코드
            exception_records = []  # 예외 사항 레코드
            
            # 예외 처리할 의사명 관련 데이터 저장 (중복 카운팅 방지)
            excluded_record_keys = set()  # 이미 예외 처리된 레코드의 키 (date_str, name_value)
            
            # 파일 크기에 따라 자동으로 chunk_size 결정
            file_size = os.path.getsize(payment_file)
            chunk_size = None
            if file_size > 5 * 1024 * 1024:  # 5MB 이상
                chunk_size = 10000
                
            # 파일 읽기
            payment_df = self.read_csv_with_encoding(payment_file, chunk_size=chunk_size)
            if payment_df is None or payment_df.empty:
                self.logger.warning("PaymentItems 파일이 비어있거나 읽을 수 없습니다.")
                return False
            
            # CSV 컬럼 확인 및 로깅
            self.logger.info(f"CSV 파일 컬럼: {list(payment_df.columns)}")
            
            # 메인 파일 열기
            wb = load_workbook(main_file)
            
            # Sales 시트 선택
            if 'Sales' in wb.sheetnames:
                sheet = wb['Sales']
            else:
                sheet = wb.active
                self.logger.warning(f"'Sales' 시트를 찾을 수 없어 현재 활성 시트({sheet.title})를 사용합니다.")
                
            # 고객관리자동 테이블 찾기
            table = self.find_table("고객관리자동", wb)
            if not table:
                self.logger.error("고객관리자동 테이블을 찾을 수 없습니다.")
                messagebox.showerror("오류", "고객관리자동 테이블을 찾을 수 없습니다. 파일 구조를 확인해주세요.")
                return False
            
            # 테이블 범위 파싱
            min_col, min_row, max_col, max_row = range_boundaries(table.ref)
            self.logger.info(f"고객관리자동 테이블 범위: 행({min_row}~{max_row}), 열({min_col}~{max_col})")
            
            # 헤더 매핑 생성
            headers = []
            for col in range(min_col, max_col + 1):
                cell_value = sheet.cell(row=min_row, column=col).value
                headers.append(cell_value if cell_value else '')
            
            self.logger.info(f"고객관리자동 테이블 헤더: {headers}")
            
            # 필요한 컬럼 찾기
            header_mapping = {}
            for i, header in enumerate(headers):
                col_index = i + min_col
                if header == 'No.' or header == 'No' or header == '번호':
                    header_mapping['No.'] = col_index
                elif header == '날짜' or 'date' in str(header).lower():
                    header_mapping['날짜'] = col_index
                elif header == '환자 명' or '환자명' in header or '환자' in header:
                    header_mapping['환자 명'] = col_index
                elif header == '진단 의사명' or '의사명' in header:
                    header_mapping['진단 의사명'] = col_index
                elif header == 'Note' or header == '설명' or header == '메모':
                    header_mapping['Note'] = col_index
                elif header == 'Price Table' or header == '가격':
                    header_mapping['Price Table'] = col_index
                elif header == '성별' or 'gender' in str(header).lower():
                    header_mapping['성별'] = col_index
                elif header == 'States' or header == '상태' or '현재 있는 주' in str(header):
                    header_mapping['States'] = col_index
                
            # 모든 헤더 매핑 로깅
            self.logger.info(f"전체 헤더 매핑: {header_mapping}")
            
            # 중복 데이터 확인을 위한 기존 데이터 수집
            existing_data = set()
            if '날짜' in header_mapping and '환자 명' in header_mapping:
                for row in range(min_row + 1, max_row + 1):
                    date_value = sheet.cell(row=row, column=header_mapping['날짜']).value
                    name_value = sheet.cell(row=row, column=header_mapping['환자 명']).value
                    if date_value and name_value:
                        if isinstance(date_value, datetime):
                            date_str = date_value.strftime('%Y-%m-%d %H:%M')
                        else:
                            date_str = str(date_value)
                        existing_data.add((date_str, str(name_value)))
            
            # 모든 데이터가 중복인지 확인
            all_duplicate = True
            duplicate_count = 0
            non_duplicate_count = 0
            
            # 중복 여부만 확인하기 위한 임시 세트 생성
            temp_check_set = existing_data.copy()
            
            for _, row in payment_df.iterrows():
                date_value = self.format_date(row.get('날짜', ''), include_time=True)
                name_value = row.get('환자', '')
                doctor_name = row.get('의료인 이름', '')
                
                # 환자명이 제외 목록에 있으면 건너뛰기
                if hasattr(self, 'excluded_patients') and name_value and name_value.strip() in self.excluded_patients:
                    self.logger.info(f"제외할 환자명 감지: {name_value}, 처리 건너뛰기")
                    exception_records.append({
                        '환자명': name_value,
                        '날짜': date_value,
                        '진단 의사명': doctor_name,
                        '설명': row.get('설명', ''),
                        '가격': row.get('가격', '') or f"{row.get('양', '')} {row.get('통화', '')}",
                        '건너뛴 이유': '예외 환자명'
                    })
                    exception_count += 1
                    continue
                
                # 의사명이 제외 목록에 있으면 건너뛰기 - 예외 사항으로 처리
                try:
                    if hasattr(self, 'excluded_doctors') and doctor_name and doctor_name.strip() in self.excluded_doctors:
                        self.logger.info(f"제외할 의사명 감지: {doctor_name}, 처리 건너뛰기")
                        exception_records.append({
                            '환자명': name_value,
                            '날짜': date_value,
                            '진단 의사명': doctor_name,
                            '설명': row.get('설명', ''),
                            '가격': row.get('가격', '') or f"{row.get('양', '')} {row.get('통화', '')}",
                            '건너뛴 이유': '예외 사항'
                        })
                        exception_count += 1
                        
                        # 이미 처리한 예외 레코드 키 저장
                        if isinstance(date_value, datetime):
                            date_str = date_value.strftime('%Y-%m-%d %H:%M')
                        else:
                            date_str = str(date_value)
                        excluded_record_keys.add((date_str, str(name_value)))
                        
                        continue
                except:
                    pass
                
                if date_value and name_value:
                    if isinstance(date_value, datetime):
                        date_str = date_value.strftime('%Y-%m-%d %H:%M')
                    else:
                        date_str = str(date_value)
                    
                    # 원본 이름으로 중복 확인 (임시 세트 사용)
                    if (date_str, str(name_value)) in temp_check_set:
                        # 여기서는 로그나 레코드 추가를 하지 않고 카운트만 증가
                        duplicate_count += 1
                    else:
                        all_duplicate = False
                        non_duplicate_count += 1
                        # 임시 세트에만 추가하고 existing_data는 수정하지 않음
                        temp_check_set.add((date_str, str(name_value)))
            
            # 전체 중복 여부 결정 (예외 사항은 중복에서 제외)
            all_duplicate = (non_duplicate_count == 0 and duplicate_count > 0)
            
            # 모든 데이터가 중복이면 SKIPPED 폴더로 이동
            if all_duplicate and len(exception_records) == 0:
                self.logger.info("모든 데이터가 중복되어 SKIPPED 폴더로 이동합니다.")
                skipped_dir = os.path.join(os.path.dirname(payment_file), "SKIPPED")
                os.makedirs(skipped_dir, exist_ok=True)
                
                target_file = os.path.join(skipped_dir, os.path.basename(payment_file))
                if os.path.exists(target_file):
                    base, ext = os.path.splitext(target_file)
                    target_file = f"{base}_{datetime.now().strftime('%Y%m%d_%H%M%S')}{ext}"
                
                # 중복 데이터 상세 정보 수집
                duplicate_details = []
                for record in skipped_records:
                    duplicate_details.append(
                        f"▶ 중복 레코드\n"
                        f"  - 환자명: {record['환자명']}\n"
                        f"  - 날짜: {record['날짜']}\n"
                        f"  - 진단 의사명: {record['진단 의사명']}\n"
                        f"  - 가격: {record['가격']}\n"
                        f"  - 설명: {record['설명']}\n"
                    )
                
                # 상세 정보 구성
                details = (
                    f"처리된 파일: {payment_file}\n\n"
                    f"▶ 테이블 정보\n"
                    f"- 시작 행: {min_row}\n"
                    f"- 종료 행: {max_row}\n"
                    f"- 처리된 컬럼: {', '.join(header_mapping.keys())}\n\n"
                    f"▶ 처리 결과\n"
                    f"- 총 레코드 수: {len(payment_df)}개\n"
                    f"- 중복으로 건너뛴 레코드: {duplicate_count}개\n\n"
                )
                
                if duplicate_details:
                    details += f"=== 중복으로 건너뛴 레코드 목록 ===\n\n" + "\n".join(duplicate_details)
                
                details += "\n파일은 SKIPPED 폴더로 이동되었습니다."
                
                shutil.move(payment_file, target_file)
                self.logger.info(f"중복 파일 이동: {target_file}")
                
                # 결과 알림창 표시
                self.show_detailed_result(
                    "처리 완료",
                    f"PaymentItems 파일이 모두 중복되어 건너뛰었습니다.\n총 {len(payment_df)}건의 중복 레코드",
                    details
                )
                return True
            
            # 마지막 No. 값 가져오기
            last_no = 0
            if 'No.' in header_mapping:
                for row in range(min_row + 1, max_row + 1):
                    cell_value = sheet.cell(row=row, column=header_mapping['No.']).value
                    if cell_value is not None:
                        try:
                            if isinstance(cell_value, str):
                                num_str = ''.join(filter(str.isdigit, cell_value))
                                if num_str:
                                    last_no = max(last_no, int(num_str))
                            else:
                                last_no = max(last_no, int(cell_value))
                        except (ValueError, TypeError):
                            pass
            
            # 데이터 추가
            current_row = max_row + 1
            processed_count = 0
            
            for _, row in payment_df.iterrows():
                # 중복 확인
                date_value = self.format_date(row.get('날짜', ''), include_time=True)
                name_value = row.get('환자', '')
                doctor_name = row.get('의료인 이름', '')
                
                # 환자명이 제외 목록에 있으면 건너뛰기
                if hasattr(self, 'excluded_patients') and name_value and name_value.strip() in self.excluded_patients:
                    self.logger.info(f"제외할 환자명 감지: {name_value}, 처리 건너뛰기")
                    continue
                
                # 의사명이 제외 목록에 있으면 건너뛰기 - 예외 사항으로 처리
                try:
                    if hasattr(self, 'excluded_doctors') and doctor_name and doctor_name.strip() in self.excluded_doctors:
                        # 이미 이전 단계에서 처리한 예외 레코드인지 확인
                        if isinstance(date_value, datetime):
                            date_str = date_value.strftime('%Y-%m-%d %H:%M')
                        else:
                            date_str = str(date_value)
                            
                        if (date_str, str(name_value)) in excluded_record_keys:
                            # 이미 처리된 예외 레코드는 건너뛰기
                            continue
                            
                        self.logger.info(f"제외할 의사명 감지: {doctor_name}, 처리 건너뛰기")
                        exception_records.append({
                            '환자명': name_value,
                            '날짜': date_value,
                            '진단 의사명': doctor_name,
                            '설명': row.get('설명', ''),
                            '가격': row.get('가격', '') or f"{row.get('양', '')} {row.get('통화', '')}",
                            '건너뛴 이유': '예외 사항'
                        })
                        exception_count += 1
                        continue
                except:
                    pass
                
                if date_value and name_value:
                    if isinstance(date_value, datetime):
                        date_str = date_value.strftime('%Y-%m-%d %H:%M')
                    else:
                        date_str = str(date_value)
                    
                    # 중복 레코드 확인 및 처리
                    if (date_str, str(name_value)) in existing_data:
                        self.logger.warning(f"중복 데이터: {date_str}, {name_value}")
                        skipped_records.append({
                            '환자명': name_value,
                            '날짜': date_value,
                            '진단 의사명': doctor_name,
                            '설명': row.get('설명', ''),
                            '가격': row.get('가격', '') or f"{row.get('양', '')} {row.get('통화', '')}",
                            '건너뛴 이유': '중복 데이터'
                        })
                        skipped_count += 1
                        continue
                    
                    existing_data.add((date_str, str(name_value)))
                
                # No. 필드 업데이트
                if 'No.' in header_mapping:
                    last_no += 1
                    sheet.cell(row=current_row, column=header_mapping['No.']).value = last_no
                
                # 날짜 필드 업데이트
                if '날짜' in header_mapping and '날짜' in row:
                    cell = sheet.cell(row=current_row, column=header_mapping['날짜'])
                    cell.value = date_value
                    cell.number_format = 'yyyy-mm-dd hh:mm'
                
                # 환자 명 필드 업데이트
                if '환자 명' in header_mapping and '환자' in row:
                    sheet.cell(row=current_row, column=header_mapping['환자 명']).value = row['환자']
                
                # 진단 의사명 필드 업데이트
                if '진단 의사명' in header_mapping and '의료인 이름' in row:
                    sheet.cell(row=current_row, column=header_mapping['진단 의사명']).value = row['의료인 이름']
                
                # Note 필드 업데이트
                if 'Note' in header_mapping and '설명' in row:
                    sheet.cell(row=current_row, column=header_mapping['Note']).value = row['설명']
                
                # Price Table 필드 업데이트 (양과 통화 결합)
                if 'Price Table' in header_mapping:
                    if '양' in row and '통화' in row:
                        amount = row['양']
                        currency = row['통화']
                        if pd.notnull(amount) and pd.notnull(currency):
                            if currency.upper() == 'USD':
                                price_value = f'${amount}'
                            else:
                                price_value = f'{amount} {currency}'
                            sheet.cell(row=current_row, column=header_mapping['Price Table']).value = price_value
                    elif '가격' in row:
                        # '가격' 열이 있는 경우 직접 사용
                        sheet.cell(row=current_row, column=header_mapping['Price Table']).value = row['가격']
                
                current_row += 1
                processed_count += 1
            
            # 테이블 범위 확장
            if processed_count > 0:
                new_range = f"{get_column_letter(min_col)}{min_row}:{get_column_letter(max_col)}{max_row + processed_count}"
                table.ref = new_range
                self.logger.info(f"테이블 범위 확장: {table.ref}")
            
            # 변경사항 저장
            wb.save(main_file)
            
            # 결과 메시지 구성 - 예외와 중복 구분
            summary_parts = []
            summary_parts.append(f"PaymentItems 처리가 완료되었습니다.\n총 {len(payment_df)}건 중 {processed_count}건 처리됨")
            
            if skipped_count > 0:
                summary_parts.append(f"{skipped_count}건 중복 제외")
                
            if exception_count > 0:
                summary_parts.append(f"{exception_count}건 예외 사항 제외")
            
            summary = ", ".join(summary_parts)
            
            # 중복 레코드 상세 정보 구성
            duplicate_details = []
            for record in skipped_records:
                duplicate_details.append(
                    f"▶ 중복 레코드\n"
                    f"  - 환자명: {record['환자명']}\n"
                    f"  - 날짜: {record['날짜']}\n"
                    f"  - 진단 의사명: {record['진단 의사명']}\n"
                    f"  - 가격: {record['가격']}\n"
                    f"  - 설명: {record['설명']}\n"
                )
            
            # 예외 항목 상세 정보 구성
            exception_details = []
            for record in exception_records:
                exception_details.append(
                    f"▶ 예외 사항\n"
                    f"  - 환자명: {record['환자명']}\n"
                    f"  - 날짜: {record['날짜']}\n"
                    f"  - 진단 의사명: {record['진단 의사명']}\n"
                    f"  - 가격: {record['가격']}\n"
                    f"  - 설명: {record['설명']}\n"
                )
                
            # 상세 정보 구성
            details = (
                f"처리된 파일: {payment_file}\n\n"
                f"▶ 테이블 정보\n"
                f"- 시작 행: {min_row}\n"
                f"- 종료 행: {max_row + processed_count}\n"
                f"- 처리된 컬럼: {', '.join(header_mapping.keys())}\n\n"
                f"▶ 처리 결과\n"
                f"- CSV 파일 레코드 수: {len(payment_df)}개\n"
                f"- 처리된 레코드: {processed_count}개\n"
                f"- 중복으로 건너뛴 레코드: {skipped_count}개\n"
                f"- 예외 사항으로 건너뛴 레코드: {exception_count}개\n"
                f"- 합계: {processed_count + skipped_count + exception_count}개\n"
            )
            
            # 예외 항목 정보 추가
            if exception_count > 0 and exception_details:
                details += f"\n=== 예외 사항으로 건너뛴 레코드 목록 ({exception_count}건) ===\n\n" + "\n".join(exception_details)
            
            # 중복 레코드 정보 추가
            if skipped_count > 0 and duplicate_details:
                details += f"\n=== 중복으로 건너뛴 레코드 목록 ({skipped_count}건) ===\n\n" + "\n".join(duplicate_details)
            
            # 처리된 파일 이동
            done_dir = os.path.join(os.path.dirname(payment_file), "DONE")
            os.makedirs(done_dir, exist_ok=True)
            
            target_file = os.path.join(done_dir, os.path.basename(payment_file))
            if os.path.exists(target_file):
                base, ext = os.path.splitext(target_file)
                target_file = f"{base}_{datetime.now().strftime('%Y%m%d_%H%M%S')}{ext}"
            
            shutil.move(payment_file, target_file)
            self.logger.info(f"처리된 파일 이동: {target_file}")
            
            # 결과 알림창 표시
            self.show_detailed_result("처리 완료", summary, details)
            
            return True
            
        except Exception as e:
            self.logger.error(f"결제 항목 처리 중 오류 발생: {str(e)}")
            self.logger.error(traceback.format_exc())
            messagebox.showerror("오류", f"PaymentItems 처리 중 오류 발생:\n{str(e)}")
            return False
    
    def standardize_register_dates_in_patient_table(self, sheet, table):
        """Convert '등록 날짜' column format to '년,월,일'"""
        # Get table range
        table_range = table.ref
        min_col, min_row, max_col, max_row = range_boundaries(table_range)
        
        # Find '등록 날짜' column
        header_row = []
        for col in range(min_col, max_col + 1):
            cell_value = sheet.cell(row=min_row, column=col).value
            header_row.append(cell_value if cell_value else f"Column_{col}")
            
        reg_date_col = next((i + min_col for i, header in enumerate(header_row) if header == "등록 날짜"), None)
        
        if reg_date_col is None:
            print("'등록 날짜' 열을 찾을 수 없습니다.")
            return
            
        # Update registration dates
        for row in range(min_row + 1, max_row + 1):
            date_cell = sheet.cell(row=row, column=reg_date_col)
            date_value = date_cell.value
            
            if date_value:
                try:
                    # 이미 '년,월,일' 형식인 경우 건너뛰기
                    if isinstance(date_value, str) and "년" in date_value and "월" in date_value and "일" in date_value:
                        continue
                        
                    # '7월 15, 2024' 형식 처리
                    if isinstance(date_value, str) and "월" in date_value and "," in date_value:
                        try:
                            # 월, 일, 연도 추출
                            month = int(date_value.split("월")[0])
                            day = int(date_value.split(",")[0].split("월")[1].strip())
                            year = int(date_value.split(",")[1].strip())
                            dt = pd.Timestamp(year=year, month=month, day=day)
                        except:
                            dt = pd.to_datetime(date_value, errors='coerce')
                    else:
                        dt = pd.to_datetime(date_value, errors='coerce')
                    
                    if pd.notnull(dt):
                        formatted_date = f"{dt.year}년,{dt.month}월,{dt.day}일"
                        date_cell.value = formatted_date
                        print(f"날짜 변환 성공 ({row}행): {date_value} -> {formatted_date}")
                    else:
                        print(f"날짜 변환 실패 ({row}행): {date_value}")
                except Exception as e:
                    print(f"날짜 변환 오류 ({row}행, 값: {date_value}): {str(e)}")
    
    def update_patient_info(self):
        """Update patient information in the customer management table"""
        try:
            self.logger.info("환자 정보 업데이트 작업 시작")
            
            # 메인 파일 확인
            main_file = self.find_main_file()
            if not main_file:
                self.logger.error("메인 파일을 찾을 수 없음")
                messagebox.showerror("오류", "메인 파일을 찾을 수 없습니다. 파일 감지를 먼저 실행해주세요.")
                self.enable_buttons()
                return
            
            self.logger.info(f"메인 파일 발견: {main_file}")
            
            # 파일 접근 가능 여부 확인
            if not self.check_file_access(main_file):
                self.logger.error(f"메인 파일 접근 불가: {main_file}")
                messagebox.showerror("오류", f"메인 파일이 열려있거나 접근할 수 없습니다.\n파일을 닫고 다시 시도해주세요: {main_file}")
                self.enable_buttons()
                return
            
            # Create backup
            try:
                backup_dir = os.path.join(os.path.dirname(main_file), "BACK UP")
                os.makedirs(backup_dir, exist_ok=True)
                backup_file = os.path.join(backup_dir, f"BACKUP_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{os.path.basename(main_file)}")
                self.logger.info(f"백업 폴더 생성/확인: {backup_dir}")
                self.logger.info(f"백업 파일 생성 시도: {backup_file}")
                shutil.copy2(main_file, backup_file)
                self.logger.info(f"메인 파일 백업 생성 완료: {backup_file}")
            except Exception as e:
                self.logger.error(f"백업 생성 중 오류 발생: {str(e)}")
                if not os.path.exists(main_file):
                    self.logger.error(f"메인 파일을 찾을 수 없음: {main_file}")
                    messagebox.showerror("오류", f"메인 파일을 찾을 수 없습니다: {main_file}")
                    self.enable_buttons()
                    return
                else:
                    self.logger.warning("백업 생성은 실패했지만 메인 파일은 존재함. 계속 진행합니다.")
            
            # Load workbook
            self.logger.info("엑셀 파일 로드 중...")
            wb = load_workbook(main_file)
            
            # Find the tables
            self.logger.info("테이블 검색 중...")
            patient_table = self.find_table("환자자동", wb)
            customer_table = self.find_table("고객관리자동", wb)
            
            if not patient_table:
                self.logger.error("'환자자동' 테이블을 찾을 수 없음")
                messagebox.showerror("오류", "'환자자동' 테이블을 찾을 수 없습니다. 파일 구조를 확인해주세요.")
                self.enable_buttons()
                return
                
            if not customer_table:
                self.logger.error("'고객관리자동' 테이블을 찾을 수 없습니다.")
                messagebox.showerror("오류", "'고객관리자동' 테이블을 찾을 수 없습니다. 파일 구조를 확인해주세요.")
                self.enable_buttons()
                return
                
            # Get patient table data
            patient_range = patient_table.ref
            p_min_col, p_min_row, p_max_col, p_max_row = range_boundaries(patient_range)
            self.logger.info(f"환자자동 테이블 범위: 시작 행={p_min_row}, 끝 행={p_max_row}, 시작 열={p_min_col}, 끝 열={p_max_col}")
            
            # Read patient table headers
            patient_headers = []
            for col in range(p_min_col, p_max_col + 1):
                cell_value = wb['Patients'].cell(row=p_min_row, column=col).value
                patient_headers.append(cell_value if cell_value else f"Column_{col}")
            
            self.logger.debug(f"환자자동 테이블 헤더: {patient_headers}")
                
            # Find columns in patient table (0-based index)
            p_name_col = next((i for i, header in enumerate(patient_headers) if header == "이름"), None)
            p_email_col = next((i for i, header in enumerate(patient_headers) if header == "이메일"), None)
            p_dob_col = next((i for i, header in enumerate(patient_headers) if header == "생년월일"), None)  # 생년월일로 검색
            # 생년월일 컬럼이 없으면 생년 컬럼을 찾습니다
            if p_dob_col is None:
                p_dob_col = next((i for i, header in enumerate(patient_headers) if header == "생년"), None)
            p_gender_col = next((i for i, header in enumerate(patient_headers) if header == "성별"), None)
            p_state_col = next((i for i, header in enumerate(patient_headers) if header == "현재 있는 주"), None)
            p_age_col = next((i for i, header in enumerate(patient_headers) if header == "나이"), None)
            p_reg_date_col = next((i for i, header in enumerate(patient_headers) if header == "등록 날짜"), None)
            p_city_col = next((i for i, header in enumerate(patient_headers) if header == "도시"), None)
            
            # 컬럼 찾기 결과 로깅
            self.logger.info("\n=== 환자자동 테이블 컬럼 정보 ===")
            self.logger.info(f"이름 컬럼: {p_name_col}")
            self.logger.info(f"등록 날짜 컬럼: {p_reg_date_col}")
            self.logger.info(f"생년/생년월일 컬럼: {p_dob_col}")
            self.logger.info(f"현재 있는 주 컬럼: {p_state_col}")
            self.logger.info(f"성별 컬럼: {p_gender_col}")
            self.logger.info(f"나이 컬럼: {p_age_col}")
            
            # 이메일과 도시를 필수 요구사항에서 제외 (이름과 생년만 필수)
            if not all([p_name_col, p_dob_col]):
                self.logger.error(f"필수 컬럼을 찾을 수 없습니다. 이름: {p_name_col}, 생년: {p_dob_col}")
                return False
                
            # 환자자동 테이블의 생년월일 헤더를 생년으로 변경
            patients_sheet = wb['Patients']
            cell = patients_sheet.cell(row=p_min_row, column=p_min_col + p_dob_col)
            old_value = cell.value
            cell.value = "생년"
            self.logger.info(f"환자자동 테이블 헤더 변경: '{old_value}' → '생년'")

            # 헤더 목록 업데이트
            patient_headers[p_dob_col] = "생년"
            
            # 환자자동 테이블의 도시와 이메일 컬럼 삭제
            cols_to_delete = []
            
            # 도시 컬럼 찾기
            p_city_col = next((i for i, header in enumerate(patient_headers) if header == "도시"), None)
            if p_city_col is not None:
                cols_to_delete.append(p_min_col + p_city_col)
                self.logger.info(f"도시 컬럼 삭제 예정: 열 {p_min_col + p_city_col}")
            
            # 이메일 컬럼 찾기
            if p_email_col is not None:
                cols_to_delete.append(p_min_col + p_email_col)
                self.logger.info(f"이메일 컬럼 삭제 예정: 열 {p_min_col + p_email_col}")
            
            # 컬럼 삭제 (인덱스가 큰 순서대로 삭제해야 인덱스 변경 문제 없음)
            if cols_to_delete:
                for col_idx in sorted(cols_to_delete, reverse=True):
                    try:
                        self.logger.info(f"컬럼 삭제 시도: 열 {col_idx}")
                        patients_sheet.delete_cols(col_idx, 1)
                        self.logger.info(f"컬럼 삭제 성공: 열 {col_idx}")
                        
                        # 테이블 범위 업데이트
                        p_max_col -= 1
                        
                        # 테이블 참조 업데이트
                        patient_table.ref = f"{get_column_letter(p_min_col)}{p_min_row}:{get_column_letter(p_max_col)}{p_max_row}"
                        self.logger.info(f"테이블 범위 업데이트: {patient_table.ref}")
                    except Exception as e:
                        self.logger.error(f"컬럼 삭제 실패: {str(e)}")
            
            # 생년월일 데이터를 생년(연도)만 추출하여 저장
            birth_year_updates = 0
            for p_row in range(p_min_row + 1, p_max_row + 1):
                birth_date = patients_sheet.cell(row=p_row, column=p_min_col + p_dob_col).value
                if birth_date:
                    try:
                        # 날짜 객체인 경우
                        if isinstance(birth_date, datetime):
                            birth_year = birth_date.year
                            patients_sheet.cell(row=p_row, column=p_min_col + p_dob_col).value = birth_year
                            birth_year_updates += 1
                        # 문자열에서 연도 추출
                        elif isinstance(birth_date, str):
                            # 다양한 형식 처리
                            date_patterns = [
                                r'(\d{4})[/\-\.](0?[1-9]|1[0-2])[/\-\.](0?[1-9]|[12][0-9]|3[01])',  # YYYY/MM/DD
                                r'(0?[1-9]|1[0-2])[/\-\.](0?[1-9]|[12][0-9]|3[01])[/\-\.](\d{4})',  # MM/DD/YYYY
                                r'(0?[1-9]|[12][0-9]|3[01])[/\-\.](0?[1-9]|1[0-2])[/\-\.](\d{4})',  # DD/MM/YYYY
                                r'(\d{4})년\s*(0?[1-9]|1[0-2])월\s*(0?[1-9]|[12][0-9]|3[01])일',     # YYYY년 MM월 DD일
                                r'(\d{4})',  # 연도만 (YYYY)
                                r'(?:0?[1-9]|1[0-2])월\s*(?:0?[1-9]|[12][0-9]|3[01]),\s*(\d{4})'  # MM월 DD, YYYY
                            ]
                            
                            birth_year = None
                            for pattern in date_patterns:
                                match = re.search(pattern, birth_date)
                                if match:
                                    if '년' in pattern:  # 한국식
                                        birth_year = int(match.group(1))
                                    elif pattern == r'(\d{4})':  # 연도만
                                        birth_year = int(match.group(1))
                                    elif pattern.endswith(r'(\d{4})'):  # MM월 DD, YYYY
                                        birth_year = int(match.group(1))
                                    elif '/' in pattern or '-' in pattern or '.' in pattern:
                                        # 패턴에 따라 연도 위치가 다를 수 있음
                                        if pattern.startswith(r'(\d{4})'):  # YYYY/MM/DD
                                            birth_year = int(match.group(1))
                                        else:  # MM/DD/YYYY 또는 DD/MM/YYYY
                                            birth_year = int(match.group(3))
                                        break
                            
                            if birth_year:
                                patients_sheet.cell(row=p_row, column=p_min_col + p_dob_col).value = birth_year
                                birth_year_updates += 1
                                
                        # 숫자인 경우 (엑셀 내부 표현)
                        elif isinstance(birth_date, (int, float)) and 1900 <= birth_date <= 2100:
                            birth_year = int(birth_date)
                            # 이미 연도만 있는 경우이므로 추가 변환 불필요
                        # 엑셀 날짜 시리얼 넘버인 경우
                        elif isinstance(birth_date, (int, float)):
                            # 엑셀의 날짜는 1900년 1월 1일부터의 일수
                            excel_date = datetime(1899, 12, 30) + timedelta(days=int(birth_date))
                            birth_year = excel_date.year
                            patients_sheet.cell(row=p_row, column=p_min_col + p_dob_col).value = birth_year
                            birth_year_updates += 1
                    except Exception as e:
                        self.logger.error(f"생년 처리 중 오류 (행 {p_row}): {e}")
            
            self.logger.info(f"생년월일 데이터를 생년(연도)만으로 변환 완료: 총 {birth_year_updates}건")
            
            # 로그에 도시와 이메일 컬럼 정보도 포함 (있는 경우만)
            log_message = f"환자자동 테이블 컬럼 정보: 이름={p_name_col}, 생년={p_dob_col}, 성별={p_gender_col}, 현재 있는 주={p_state_col}, 나이={p_age_col}"
            if p_email_col is not None:
                log_message += f", 이메일={p_email_col}"
            if p_city_col is not None:
                log_message += f", 도시={p_city_col}"
            self.logger.info(log_message)
            
            # Get customer management table data
            customer_range = customer_table.ref
            c_min_col, c_min_row, c_max_col, c_max_row = range_boundaries(customer_range)
            self.logger.info(f"고객관리자동 테이블 범위: 시작 행={c_min_row}, 끝 행={c_max_row}, 시작 열={c_min_col}, 끝 열={c_max_col}")
            
            # Read customer management table headers
            customer_headers = []
            for col in range(c_min_col, c_max_col + 1):
                cell_value = wb['Sales'].cell(row=c_min_row, column=col).value
                customer_headers.append(cell_value if cell_value else f"Column_{col}")
            
            self.logger.debug(f"고객관리자동 테이블 헤더: {customer_headers}")
                
            # Find columns in customer management table
            c_patient_name_col = next((i for i, header in enumerate(customer_headers) if '환자 명' in str(header) or 'patient' in str(header).lower()), None)
            c_no_col = next((i for i, header in enumerate(customer_headers) if header == "No."), None)
            c_age_col = next((i for i, header in enumerate(customer_headers) if 'ages' in str(header).lower()), None)
            c_birth_year_col = next((i for i, header in enumerate(customer_headers) if '생년' in str(header) or 'birth' in str(header).lower()), None)
            c_gender_col = next((i for i, header in enumerate(customer_headers) if '성별' in str(header) or 'gender' in str(header).lower()), None)
            c_state_col = next((i for i, header in enumerate(customer_headers) if 'states' in str(header).lower()), None)
            c_price_col = next((i for i, header in enumerate(customer_headers) if 'price table' in str(header).lower()), None)
            c_doctor_col = next((i for i, header in enumerate(customer_headers) if '진단 의사명' in str(header) or '의사' in str(header) or 'doctor' in str(header).lower()), None)
            
            self.logger.debug(f"고객관리자동 테이블 헤더: {customer_headers}")
            self.logger.debug(f"환자명 컬럼: {c_patient_name_col}, No. 컬럼: {c_no_col}, Ages 컬럼: {c_age_col}, 생년 컬럼: {c_birth_year_col}")
            self.logger.debug(f"성별 컬럼: {c_gender_col}, States 컬럼: {c_state_col}, Price Table 컬럼: {c_price_col}, 의사명 컬럼: {c_doctor_col}")
            
            if c_patient_name_col is None:
                self.logger.error("고객관리자동 테이블에서 '환자 명' 컬럼을 찾을 수 없습니다.")
                return
                
            # 정규화 함수 정의
            def normalize_name(name):
                if name is None:
                    return ""
                # 대소문자 구분 제거, 공백 제거, 특수문자 제거
                return re.sub(r'[^\w\s]', '', str(name).lower().strip()).replace(" ", "")
            
            # 이름 유사도 검사 (80% 이상 유사하면 매치)
            def name_similarity(name1, name2):
                if not name1 or not name2:
                    return 0
                
                name1 = name1.lower().strip()
                name2 = name2.lower().strip()
                
                # 완전 동일한 경우
                if name1 == name2:
                    return 1.0
                
                # 한쪽이 다른쪽에 완전히 포함된 경우
                if name1 in name2 or name2 in name1:
                    return 0.9
                
                # 레벤슈타인 거리 계산 (문자열 편집 거리)
                max_len = max(len(name1), len(name2))
                if max_len == 0:
                    return 0
                
                # 편집 거리 계산
                distance = 0
                for c1, c2 in zip(name1, name2):
                    if c1 != c2:
                        distance += 1
                
                # 길이 차이 추가
                distance += abs(len(name1) - len(name2))
                
                # 유사도 점수 계산 (0~1)
                similarity = 1 - (distance / max_len)
                return similarity
            
            # 초기화 변수들
            update_count = 0
            age_updates = 0
            gender_updates = 0
            state_updates = 0
            no_updates = 0
            birth_year_updates = 0
            skipped_count = 0
            deleted_count = 0  # 삭제된 행 수를 추적하기 위한 변수 추가
            gender_skipped_count = 0  # 성별 필드가 이미 있어서 스킵된 항목 수
            state_skipped_count = 0  # States 필드가 이미 있어서 스킵된 항목 수
            
            self.logger.info("환자 정보 업데이트 시작...")
            
            # 테이블에서 가장 큰 No. 값 찾기
            max_no = 0
            if c_no_col is not None:
                for row in range(c_min_row + 1, c_max_row + 1):
                    cell_value = wb['Sales'].cell(row=row, column=c_min_col + c_no_col).value
                    if isinstance(cell_value, (int, float)) and cell_value > max_no:
                        max_no = int(cell_value)
                self.logger.debug(f"현재 테이블의 가장 큰 No. 값: {max_no}")
            
            # 고객관리자동 테이블의 모든 환자명 출력 (디버깅용)
            all_patients = []
            for c_row in range(c_min_row + 1, c_max_row + 1):
                patient_name = wb['Sales'].cell(row=c_row, column=c_min_col + c_patient_name_col).value if c_patient_name_col is not None else None
                if patient_name:
                    all_patients.append(f"{patient_name} (행: {c_row})")
            
            self.logger.debug(f"고객관리자동 테이블의 모든 환자: {', '.join(all_patients)}")
            
            # 환자자동 테이블의 모든 이름 출력 (디버깅용)
            all_names = []
            for p_row in range(p_min_row + 1, p_max_row + 1):
                p_name = wb['Patients'].cell(row=p_row, column=p_min_col + p_name_col).value if p_name_col is not None else None
                if p_name:
                    all_names.append(f"{p_name} (행: {p_row})")
            
            self.logger.debug(f"환자자동 테이블의 모든 이름: {', '.join(all_names)}")
            
            # 제외할 환자 목록
            self.logger.info(f"제외할 환자 목록: {', '.join(self.excluded_patients)}")
            
            # 제외할 의사명 목록 추가
            self.logger.info(f"제외할 의사명 목록: {', '.join(self.excluded_doctors)}")
            
            # 먼저 제외할 환자의 행 찾기
            rows_to_delete = set()
            for row in range(c_min_row + 1, c_max_row + 1):
                patient_name = wb['Sales'].cell(row=row, column=c_min_col + c_patient_name_col).value
                if patient_name and patient_name.strip() in self.excluded_patients:
                    rows_to_delete.add(row)
                    self.logger.info(f"제외할 환자 발견: '{patient_name}', 행 {row}")
            
            # 제외할 환자의 행 삭제
            if rows_to_delete:
                for row in sorted(rows_to_delete, reverse=True):
                    wb['Sales'].delete_rows(row)
                    self.logger.info(f"제외할 환자 행 {row} 삭제 완료")
                
                # 테이블 범위 조정
                deleted_count = len(rows_to_delete)  # 삭제된 행 수 기록
                c_max_row -= deleted_count
                self.logger.info(f"테이블 범위 조정: 삭제된 행 수 = {deleted_count}, 새로운 마지막 행 = {c_max_row}")
                
                # 테이블 범위 업데이트
                try:
                    sales_sheet = wb['Sales']
                    if hasattr(sales_sheet, 'tables') and sales_sheet.tables:
                        table = next(iter(sales_sheet.tables.values()))
                        current_ref = table.ref
                        new_ref = f"{current_ref.split(':')[0]}:{openpyxl.utils.get_column_letter(c_max_col)}{c_max_row}"
                        table.ref = new_ref
                        self.logger.info(f"테이블 범위 업데이트: {current_ref} → {new_ref}")
                except Exception as e:
                    self.logger.error(f"테이블 범위 업데이트 중 오류 발생: {str(e)}")
                    self.logger.error(traceback.format_exc())
            
            # Process customer management table rows
            for c_row in range(c_min_row + 1, c_max_row + 1):
                # 실제 워크북의 행/열 인덱스로 변환
                c_row_idx = c_row
                
                # 환자 이름 가져오기
                patient_name_idx = c_min_col + c_patient_name_col
                patient_name = wb['Sales'].cell(row=c_row_idx, column=patient_name_idx).value
                
                # Skip if patient name is empty or in excluded list
                if not patient_name or patient_name.strip() in self.excluded_patients:
                    continue
                    
                self.logger.debug(f"처리 중인 환자: {patient_name} (행: {c_row_idx})")
                
                # 환자자동 테이블에서 일치하는 환자 찾기
                best_match = None
                highest_similarity = 0
                match_row = None
                
                # 이미 초성/이니셜로 변환된 환자 이름을 원래 형태로 복원하는 매칭 작업이 필요함
                for p_row in range(p_min_row + 1, p_max_row + 1):
                    p_name = wb['Patients'].cell(row=p_row, column=p_min_col + p_name_col).value
                    if not p_name:
                        continue
                    
                    # 이름 기반으로 매칭 (정확히 일치하는 경우 우선)
                    if p_name == patient_name:
                        best_match = p_name
                        match_row = p_row
                        highest_similarity = 1.0
                        self.logger.debug(f"이름 정확히 일치: {p_name} <-> {patient_name}")
                        break
                    
                    # 기존 유사도 비교 로직 유지 (정확히 일치하지 않는 경우)
                    similarity = name_similarity(p_name, patient_name)
                    if similarity > highest_similarity and similarity >= 0.8:  # 80% 이상 유사도
                        highest_similarity = similarity
                        best_match = p_name
                        match_row = p_row
                
                # 일치하는 환자 정보가 있을 경우
                if best_match:
                    self.logger.debug(f"환자 '{patient_name}'의 매칭 결과: '{best_match}' (유사도: {highest_similarity:.2f})")
                    self.logger.debug(f"매치된 행: {match_row}")
                    
                    # 환자 명을 원래 이름 그대로 사용 (초성/이니셜 변환 제거)
                    wb['Sales'].cell(row=c_row_idx, column=patient_name_idx).value = best_match
                    self.logger.debug(f"환자 명 원본 그대로 사용: {best_match}")
                    
                    # 고객관리 테이블에 환자 정보 업데이트
                    birth_year = None
                    gender = None
                    state = None
                    
                    # 생년 컬럼에서 연도 가져오기
                    if p_dob_col is not None:
                        birth_date = wb['Patients'].cell(row=match_row, column=p_min_col + p_dob_col).value
                        if birth_date:
                            try:
                                # 이미 숫자인 경우 (연도만 있는 경우)
                                if isinstance(birth_date, (int, float)) and 1900 <= birth_date <= 2100:
                                    birth_year = int(birth_date)
                                # 그 외 경우는 문자열이나 날짜 객체일 수 있음
                                else:
                                    self.logger.debug(f"생년 데이터 형식: {type(birth_date)}, 값: {birth_date}")
                                    # 문자열이면 직접 정수로 변환 시도
                                    if isinstance(birth_date, str) and birth_date.isdigit():
                                        birth_year = int(birth_date)
                                    else:
                                        # 객체가 날짜 형식이면 연도 추출
                                        try:
                                            if isinstance(birth_date, datetime):
                                                birth_year = birth_date.year
                                            else:
                                                # 다른 형식이면 변환 시도
                                                dt = pd.to_datetime(birth_date, errors='coerce')
                                                if pd.notnull(dt):
                                                    birth_year = dt.year
                                        except:
                                            self.logger.warning(f"생년 데이터 처리 실패: {birth_date}")
                            except Exception as e:
                                self.logger.error(f"생년 처리 중 오류: {e}")
                    
                    if p_gender_col is not None:
                        gender = wb['Patients'].cell(row=match_row, column=p_min_col + p_gender_col).value
                        # 영문 성별을 한글로 변환
                        if gender:
                            gender = str(gender).strip()
                            if gender.lower() in ['male', 'm']:
                                gender = '남'
                            elif gender.lower() in ['female', 'f']:
                                gender = '여'
                    
                    if p_state_col is not None:
                        state = wb['Patients'].cell(row=match_row, column=p_min_col + p_state_col).value
                    
                    # 디버깅 정보 출력
                    self.logger.debug(f"환자 {best_match}의 생년: {birth_date}, 추출 연도: {birth_year}")
                    self.logger.debug(f"환자 {best_match}의 성별: {gender}")
                    self.logger.debug(f"환자 {best_match}의 현재 있는 주: {state}")
                    
                    # 고객관리자동 테이블에 정보 업데이트
                    updated = False
                    
                    # Ages 컬럼 업데이트
                    if c_age_col is not None and birth_year:
                        age_idx = c_min_col + c_age_col
                        current_age = wb['Sales'].cell(row=c_row_idx, column=age_idx).value
                        
                        # 셀이 비어있거나 값이 없는 경우 업데이트
                        if not current_age:
                            # 생년 컬럼 참조를 사용하여 현재 행 기준으로 나이 계산 수식 생성
                            birth_year_idx_letter = get_column_letter(c_min_col + c_birth_year_col)
                            # 절대 참조로 수정 (행이 삭제되어도 참조가 유지됨)
                            formula = f"=YEAR(NOW())-{birth_year_idx_letter}{c_row_idx}"
                            wb['Sales'].cell(row=c_row_idx, column=age_idx).value = formula
                            age_updates += 1
                            updated = True
                            self.logger.debug(f"Ages 업데이트: 수식 {formula}")
                    
                    # 생년 컬럼 업데이트
                    if c_birth_year_col is not None and birth_year:
                        wb['Sales'].cell(row=c_row_idx, column=c_min_col + c_birth_year_col).value = birth_year
                        birth_year_updates += 1
                        updated = True
                        self.logger.debug(f"생년 업데이트: {birth_year}")
                    
                    # 성별 컬럼 업데이트
                    if c_gender_col is not None and gender:
                        gender_idx = c_min_col + c_gender_col
                        current_gender = wb['Sales'].cell(row=c_row_idx, column=gender_idx).value
                        
                        # 셀이 비어있거나 값이 없는 경우에만 업데이트
                        if not current_gender or str(current_gender).strip() == '':
                            wb['Sales'].cell(row=c_row_idx, column=gender_idx).value = gender
                            gender_updates += 1
                            updated = True
                            self.logger.info(f"성별 업데이트: {patient_name}, {gender}")
                        else:
                            self.logger.info(f"성별 값이 이미 존재함 ({patient_name}): '{current_gender}' - 업데이트 건너뜀")
                            if 'gender_skipped_count' in locals():
                                gender_skipped_count += 1  # 스킵 카운터 증가
                    
                    # States 컬럼 업데이트
                    if c_state_col is not None and state:
                        state_idx = c_min_col + c_state_col
                        current_state = wb['Sales'].cell(row=c_row_idx, column=state_idx).value
                        
                        # 셀이 비어있거나 값이 없는 경우에만 업데이트
                        if not current_state or str(current_state).strip() == '':
                            wb['Sales'].cell(row=c_row_idx, column=state_idx).value = state
                            state_updates += 1
                            updated = True
                            self.logger.info(f"States 업데이트: {patient_name}, 현재 있는 주 = {state}")
                        else:
                            self.logger.info(f"States 값이 이미 존재함 ({patient_name}): '{current_state}' - 업데이트 건너뜀")
                            if 'state_skipped_count' in locals():
                                state_skipped_count += 1  # 스킵 카운터 증가
                    
                    if updated:
                        update_count += 1
                else:
                    self.logger.warning(f"환자 '{patient_name}'의 매칭 결과 없음")
                
                # Check if all fields are already filled
                has_all_data = True
            
            # 등록 날짜 형식 변환 및 가운데 정렬
            date_format_updates = 0
            if p_reg_date_col is not None:
                self.logger.info("등록 날짜 형식 변환 작업 시작...")
                for p_row in range(p_min_row + 1, p_max_row + 1):
                    reg_date = wb['Patients'].cell(row=p_row, column=p_reg_date_col + p_min_col).value
                    if reg_date:
                        try:
                            # 이미 형식이 '년 월 일' 형태인지 확인
                            if isinstance(reg_date, str) and "년" in reg_date and "월" in reg_date and "일" in reg_date:
                                continue
                                
                            # '7월 15, 2024' 형식 처리
                            if isinstance(reg_date, str) and "월" in reg_date and "," in reg_date:
                                try:
                                    # 월, 일, 연도 추출
                                    month = int(reg_date.split("월")[0])
                                    day = int(reg_date.split(",")[0].split("월")[1].strip())
                                    year = int(reg_date.split(",")[1].strip())
                                    dt = pd.Timestamp(year=year, month=month, day=day)
                                except:
                                    dt = pd.to_datetime(reg_date, errors='coerce')
                            else:
                                dt = pd.to_datetime(reg_date, errors='coerce')
                            
                            if pd.notnull(dt):
                                formatted_date = f"{dt.year}년 {dt.month}월 {dt.day}일"
                                wb['Patients'].cell(row=p_row, column=p_reg_date_col + p_min_col).value = formatted_date
                                date_format_updates += 1
                                self.logger.debug(f"등록 날짜 형식 변환: {reg_date} → {formatted_date}")
                        except Exception as e:
                            self.logger.warning(f"등록 날짜 처리 오류 ({p_row}행): {str(e)}")
                
                self.logger.info(f"등록 날짜 형식 변환 완료: 총 {date_format_updates}건")
            
            # Save workbook
            self.logger.info("업데이트된 내용 저장 중...")
            
            # 환불 처리 (Price Table 컬럼에 음수 값이 있는 항목 처리)
            if c_price_col is not None and c_patient_name_col is not None and c_doctor_col is not None:
                self.logger.info("환불 처리 작업 시작...")
                sales_sheet = wb['Sales']
                refund_rows_to_delete = set()  # 삭제할 행 목록
                refund_processed = 0    # 환불 처리된 건수
                
                # 테이블 모든 행을 순회하며 음수 금액 검색
                for row in range(c_min_row + 1, c_max_row + 1):
                    price_cell = sales_sheet.cell(row=row, column=c_min_col + c_price_col).value
                    
                    if price_cell and '-' in str(price_cell):
                        # 환자명과 의사명 가져오기
                        patient_name = sales_sheet.cell(row=row, column=c_min_col + c_patient_name_col).value
                        doctor_name = sales_sheet.cell(row=row, column=c_min_col + c_doctor_col).value
                        
                        # 금액에서 숫자만 추출 (부호 제외)
                        price_str = str(price_cell)
                        amount_with_sign = ''.join(c for c in price_str if c.isdigit() or c == '.' or c == '-')
                        
                        try:
                            amount = float(amount_with_sign)
                            absolute_amount = abs(amount)
                            
                            if amount < 0:  # 음수 금액인 경우
                                self.logger.info(f"음수 금액 감지: {amount}, 환자: {patient_name}, 의사명: {doctor_name}")
                                
                                # 동일 환자명과 의사명을 가진 행 중 절대값이 같은 양수 금액을 가진 행 찾기
                                match_row = None
                                
                                # 최근 행부터 역순으로 검색 (가장 최근 것 먼저 찾기 위해)
                                for r in range(c_max_row, c_min_row, -1):
                                    if r == row:  # 현재 행은 건너뛰기
                                        continue
                                        
                                    r_patient = sales_sheet.cell(row=r, column=c_min_col + c_patient_name_col).value
                                    r_doctor = sales_sheet.cell(row=r, column=c_min_col + c_doctor_col).value
                                    r_price = sales_sheet.cell(row=r, column=c_min_col + c_price_col).value
                                    
                                    # 환자명과 의사명이 일치하는지 확인
                                    if r_patient == patient_name and r_doctor == doctor_name and r_price:
                                        # 금액 추출 및 비교
                                        r_price_str = str(r_price)
                                        r_amount_str = ''.join(c for c in r_price_str if c.isdigit() or c == '.')
                                        
                                        try:
                                            r_amount = float(r_amount_str)
                                            # 절대값이 같은지 확인 (부동소수점 비교 오차 감안)
                                            if abs(r_amount - absolute_amount) < 0.01:
                                                match_row = r
                                                self.logger.info(f"삭제할 행 찾음: {r}, 금액: {r_price}")
                                                break
                                        except (ValueError, TypeError):
                                            continue
                                
                                # 일치하는 행이 있으면 삭제 목록에 추가
                                if match_row:
                                    refund_rows_to_delete.add(match_row)
                                    refund_rows_to_delete.add(row)  # 마이너스 금액이 있는 현재 행도 삭제
                                    refund_processed += 1
                                else:
                                    self.logger.warning(f"삭제할 행을 찾지 못함: 환자 {patient_name}, 의사명 {doctor_name}, 금액 {absolute_amount}")
                        except (ValueError, TypeError) as e:
                            self.logger.warning(f"금액 변환 오류: {str(e)}")
                
                # 삭제할 행 목록 확인
                if refund_rows_to_delete:
                    self.logger.info(f"\n=== 환불 처리로 삭제할 행 목록 ({len(refund_rows_to_delete)}개) ===")
                    for row in sorted(refund_rows_to_delete):
                        price = sales_sheet.cell(row=row, column=c_min_col + c_price_col).value
                        patient = sales_sheet.cell(row=row, column=c_min_col + c_patient_name_col).value
                        self.logger.info(f"행 {row}: {patient} ({price})")

                    # 행 삭제 (큰 번호부터)
                    for row in sorted(refund_rows_to_delete, reverse=True):
                        sales_sheet.delete_rows(row)
                        self.logger.info(f"행 {row} 삭제 완료")

                    # 테이블 범위 업데이트
                    new_max_row = c_max_row - len(refund_rows_to_delete)
                    old_ref = customer_table.ref
                    customer_table.ref = f"{get_column_letter(c_min_col)}{c_min_row}:{get_column_letter(c_max_col)}{new_max_row}"
                    self.logger.info(f"테이블 범위 업데이트: {old_ref} -> {customer_table.ref}")
                    
                    # 테이블 범위 업데이트 후 변수 업데이트
                    c_max_row = new_max_row
                
                # 환불 처리 결과 로깅
                self.logger.info(f"환불 처리 완료: 총 {refund_processed}건, 삭제된 행: {len(refund_rows_to_delete)}개")
                
                # 환불 처리 결과 알림창 제거
                # if refund_processed > 0:
                #     messagebox.showinfo("환불 처리 완료", f"환불 처리가 완료되었습니다.\n- 처리된 환불 건수: {refund_processed}건\n- 삭제된 행: {len(refund_rows_to_delete)}개")
                
            else:
                self.logger.warning("환불 처리에 필요한 컬럼(가격, 환자명, 의사명)을 찾을 수 없어 환불 처리를 건너뜁니다.")
            
            # 고객관리자동 테이블 빈 행 삭제 처리
            self.logger.info("고객관리자동 테이블 빈 행 삭제 작업 시작...")
            sales_sheet = wb['Sales']
            empty_sales_rows_to_delete = set()  # 삭제할 빈 행 목록
            
            # 테이블 모든 행을 순회하며 빈 행 검색
            total_rows = 0
            for row in range(c_min_row + 1, c_max_row + 1):
                total_rows += 1
                is_empty_row = True
                for col in range(c_min_col, c_max_col + 1):
                    cell_value = sales_sheet.cell(row=row, column=col).value
                    if cell_value is not None and str(cell_value).strip() != '':
                        is_empty_row = False
                        break
                
                if is_empty_row:
                    empty_sales_rows_to_delete.add(row)
                    self.logger.info(f"고객관리자동 빈 행 감지: {row}")
            
            # 빈 행 삭제 (테이블에 빈 행만 존재하는 경우는 삭제하지 않음)
            empty_sales_rows_deleted = 0
            if empty_sales_rows_to_delete and len(empty_sales_rows_to_delete) < total_rows:
                self.logger.info(f"\n=== 삭제할 고객관리자동 빈 행 목록 ({len(empty_sales_rows_to_delete)}개) ===")
                for row in sorted(empty_sales_rows_to_delete):
                    self.logger.info(f"빈 행: {row}")
                
                # 큰 번호부터 행 삭제
                for row in sorted(empty_sales_rows_to_delete, reverse=True):
                    sales_sheet.delete_rows(row)
                    self.logger.info(f"빈 행 {row} 삭제 완료")
                    empty_sales_rows_deleted += 1
                
                # 테이블 범위 업데이트
                if empty_sales_rows_deleted > 0:
                    new_max_row = c_max_row - empty_sales_rows_deleted
                    old_ref = customer_table.ref
                    customer_table.ref = f"{get_column_letter(c_min_col)}{c_min_row}:{get_column_letter(c_max_col)}{new_max_row}"
                    self.logger.info(f"테이블 범위 업데이트: {old_ref} -> {customer_table.ref}")
                    
                    # 테이블 범위 업데이트 후 변수 업데이트
                    c_max_row = new_max_row
                    
                    # 빈 행 삭제 후 수식 재적용 - 모든 Ages 열의 수식을 다시 검사하고 업데이트
                    if c_age_col is not None and c_birth_year_col is not None:
                        self.logger.info("빈 행 삭제 후 Ages 수식 재조정 시작...")
                        formula_fixes = 0
                        
                        for row in range(c_min_row + 1, c_max_row + 1):
                            # 생년 값이 있는지 확인
                            birth_year_cell = sales_sheet.cell(row=row, column=c_min_col + c_birth_year_col)
                            if birth_year_cell.value:
                                age_cell = sales_sheet.cell(row=row, column=c_min_col + c_age_col)
                                current_formula = age_cell.value
                                
                                # 수식이 있지만 행 참조가 맞지 않거나 수식이 없는 경우 업데이트
                                if current_formula is None or (isinstance(current_formula, str) and "YEAR(NOW())" in current_formula):
                                    birth_year_idx_letter = get_column_letter(c_min_col + c_birth_year_col)
                                    new_formula = f"=YEAR(NOW())-{birth_year_idx_letter}{row}"
                                    age_cell.value = new_formula
                                    formula_fixes += 1
                                    self.logger.debug(f"Ages 수식 재조정: 행 {row}, 수식 {new_formula}")
                        
                        self.logger.info(f"Ages 수식 재조정 완료: 총 {formula_fixes}건 수정됨")
            elif len(empty_sales_rows_to_delete) == total_rows:
                self.logger.info("테이블에 빈 행만 존재하여 삭제를 건너뜁니다.")
            
            # 빈 행 삭제 결과 로깅
            self.logger.info(f"고객관리자동 빈 행 삭제 완료: 총 {empty_sales_rows_deleted}개 행 삭제됨")
            
            # 환자자동 테이블 빈 행 삭제 처리
            self.logger.info("환자자동 테이블 빈 행 삭제 작업 시작...")
            patients_sheet = wb['Patients']
            empty_patients_rows_to_delete = set()  # 삭제할 빈 행 목록
            
            # 테이블 모든 행을 순회하며 빈 행 검색
            total_rows = 0
            for row in range(p_min_row + 1, p_max_row + 1):
                total_rows += 1
                is_empty_row = True
                for col in range(p_min_col, p_max_col + 1):
                    cell_value = patients_sheet.cell(row=row, column=col).value
                    if cell_value is not None and str(cell_value).strip() != '':
                        is_empty_row = False
                        break
                
                if is_empty_row:
                    empty_patients_rows_to_delete.add(row)
                    self.logger.info(f"환자자동 빈 행 감지: {row}")
            
            # 빈 행 삭제 (테이블에 빈 행만 존재하는 경우는 삭제하지 않음)
            empty_patients_rows_deleted = 0
            if empty_patients_rows_to_delete and len(empty_patients_rows_to_delete) < total_rows:
                self.logger.info(f"\n=== 삭제할 환자자동 빈 행 목록 ({len(empty_patients_rows_to_delete)}개) ===")
                for row in sorted(empty_patients_rows_to_delete):
                    self.logger.info(f"빈 행: {row}")
                
                # 큰 번호부터 행 삭제
                for row in sorted(empty_patients_rows_to_delete, reverse=True):
                    patients_sheet.delete_rows(row)
                    self.logger.info(f"빈 행 {row} 삭제 완료")
                    empty_patients_rows_deleted += 1
                
                # 테이블 범위 업데이트
                if empty_patients_rows_deleted > 0:
                    new_max_row = p_max_row - empty_patients_rows_deleted
                    old_ref = patient_table.ref
                    patient_table.ref = f"{get_column_letter(p_min_col)}{p_min_row}:{get_column_letter(p_max_col)}{new_max_row}"
                    self.logger.info(f"테이블 범위 업데이트: {old_ref} -> {patient_table.ref}")
                    
                    # 테이블 범위 업데이트 후 변수 업데이트
                    p_max_row = new_max_row
            elif len(empty_patients_rows_to_delete) == total_rows:
                self.logger.info("테이블에 빈 행만 존재하여 삭제를 건너뜁니다.")
            
            # 빈 행 삭제 결과 로깅
            self.logger.info(f"환자자동 빈 행 삭제 완료: 총 {empty_patients_rows_deleted}개 행 삭제됨")
            
            # 환자자동 테이블에 나이 계산 공식 추가
            if p_age_col is not None and p_dob_col is not None:
                self.logger.info("환자자동 테이블의 나이 계산 공식 업데이트 시작...")
                age_formula_updates = 0
                
                for row in range(p_min_row + 1, p_max_row + 1):
                    # 생년 컬럼의 값이 있을 때만 공식 추가
                    birth_year = patients_sheet.cell(row=row, column=p_min_col + p_dob_col).value
                    if birth_year:
                        age_cell = patients_sheet.cell(row=row, column=p_min_col + p_age_col)
                        # 테이블 참조 형식의 공식 사용
                        birth_col_letter = get_column_letter(p_min_col + p_dob_col)
                        
                        # 요청한 공식 적용: =DATEDIF(DATE(VALUE(RIGHT([@생년],4)),1,1), TODAY(), "Y")
                        # 테이블 참조 방식으로 [@컬럼명] 대신 실제 셀 참조로 변환
                        formula = f'=DATEDIF(DATE(VALUE(RIGHT({birth_col_letter}{row},4)),1,1), TODAY(), "Y")'
                        
                        # 공식이 없거나 수정이 필요한 경우 업데이트
                        current_formula = age_cell.value
                        if not current_formula or (isinstance(current_formula, str) and not current_formula.startswith('=DATEDIF')):
                            age_cell.value = formula
                            age_formula_updates += 1
                
                self.logger.info(f"환자자동 테이블 나이 계산 공식 업데이트 완료: 총 {age_formula_updates}건")
                
                # Age_Range 열 업데이트
                self.logger.info("환자자동 테이블의 Age_Range 공식 업데이트 시작...")
                age_range_col = None
                age_range_formula_updates = 0
                
                # Age_Range 열 찾기
                for i, header in enumerate(patient_headers):
                    if header == "Age_Range":
                        age_range_col = i
                        break
                
                if age_range_col is not None:
                    age_col_letter = get_column_letter(p_min_col + p_age_col)
                    
                    for row in range(p_min_row + 1, p_max_row + 1):
                        # 나이 셀에 값이 있는 경우에만 Age_Range 업데이트
                        age_value = patients_sheet.cell(row=row, column=p_min_col + p_age_col).value
                        if age_value:
                            age_range_cell = patients_sheet.cell(row=row, column=p_min_col + age_range_col)
                            
                            # 요청한 Age_Range 공식 적용
                            lookup_formula = f'=LOOKUP({age_col_letter}{row},{{0,20,30,40,50,60,70}},{{"10s","20s","30s","40s","50s","60s","70s+"}})'
                            
                            # 공식이 없거나 LOOKUP 함수가 아닌 경우 업데이트
                            current_formula = age_range_cell.value
                            if not current_formula or (isinstance(current_formula, str) and not current_formula.startswith('=LOOKUP')):
                                age_range_cell.value = lookup_formula
                                age_range_formula_updates += 1
                    
                    self.logger.info(f"환자자동 테이블 Age_Range 공식 업데이트 완료: 총 {age_range_formula_updates}건")
                else:
                    self.logger.warning("환자자동 테이블에서 Age_Range 컬럼을 찾을 수 없어 Age_Range 계산 공식 업데이트를 건너뜁니다.")
            else:
                self.logger.warning("환자자동 테이블에서 나이 또는 생년 컬럼을 찾을 수 없어 나이 계산 공식 업데이트를 건너뜁니다.")
            
            # 최종 가운데 정렬 적용 - 저장 직전에 실행
            self.logger.info("모든 테이블에 가운데 정렬 최종 적용 중...")
            center_alignment = Alignment(horizontal='center', vertical='center')
            
            # 환자자동 테이블 가운데 정렬 (명시적 시트명 사용)
            patients_aligned = 0
            patients_sheet = wb['Patients']
            self.logger.debug(f"환자자동 테이블 범위: 행({p_min_row}~{p_max_row}), 열({p_min_col}~{p_max_col})")
            
            try:
                for row in range(p_min_row, p_max_row + 1):
                    for col in range(p_min_col, p_max_col + 1):
                        cell = patients_sheet.cell(row=row, column=col)
                        # 모든 셀에 강제로 가운데 정렬 적용
                        cell.alignment = center_alignment
                        patients_aligned += 1
                self.logger.info(f"환자자동 테이블 가운데 정렬 완료: {patients_aligned}개 셀")
            except Exception as e:
                self.logger.error(f"환자자동 테이블 가운데 정렬 중 오류: {str(e)}")
                self.logger.error(traceback.format_exc())
            
            # 고객관리자동 테이블 가운데 정렬
            customers_aligned = 0
            sales_sheet = wb['Sales']
            
            try:
                for row in range(c_min_row, c_max_row + 1):
                    for col in range(c_min_col, c_max_col + 1):
                        cell = sales_sheet.cell(row=row, column=col)
                        # 모든 셀에 강제로 가운데 정렬 적용
                        cell.alignment = center_alignment
                        customers_aligned += 1
                self.logger.info(f"고객관리자동 테이블 가운데 정렬 완료: {customers_aligned}개 셀")
                self.logger.info("※ 모든 데이터가 가운데 정렬로 적용되었습니다.")
            except Exception as e:
                self.logger.error(f"고객관리자동 테이블 가운데 정렬 중 오류: {str(e)}")
                self.logger.error(traceback.format_exc())
            
            wb.save(main_file)
            self.logger.info(f"파일 저장 완료: {main_file}")
            
            # 파일 감지 다시 실행
            self.update_file_labels()
            
            # 업데이트 요약 정보
            summary = f"환자 정보 업데이트 완료: 총 {update_count}건\n"
            summary += f"- Ages 업데이트: {age_updates}건\n"
            summary += f"- 성별 업데이트: {gender_updates}건 (기존 값 있음: {gender_skipped_count}건)\n"
            summary += f"- States 업데이트: {state_updates}건 (기존 값 있음: {state_skipped_count}건)\n"
            summary += f"- 등록 날짜 형식 변환: {date_format_updates}건\n"
            if 'refund_processed' in locals() and refund_processed > 0:
                summary += f"- 환불 처리: {refund_processed}건 (삭제된 행: {len(refund_rows_to_delete) if 'refund_rows_to_delete' in locals() else 0}개)\n"
            if 'empty_sales_rows_deleted' in locals() and empty_sales_rows_deleted > 0:
                summary += f"- 고객관리자동 빈 행 삭제: {empty_sales_rows_deleted}개\n"
            if 'empty_patients_rows_deleted' in locals() and empty_patients_rows_deleted > 0:
                summary += f"- 환자자동 빈 행 삭제: {empty_patients_rows_deleted}개\n"
            if 'age_formula_updates' in locals() and age_formula_updates > 0:
                summary += f"- 환자자동 나이 계산 공식 업데이트: {age_formula_updates}건\n"
            if 'age_range_formula_updates' in locals() and age_range_formula_updates > 0:
                summary += f"- 환자자동 Age_Range 계산 공식 업데이트: {age_range_formula_updates}건\n"
            summary += f"- 건너뛴 항목 (이미 데이터 있음): {skipped_count}건\n"
            summary += f"- 모든 표 데이터 가운데 정렬 적용됨"
            
            self.logger.info(summary.replace('\n', ' | '))
            messagebox.showinfo("처리 완료", summary)
            
            # Ask if user wants to open the file
            if messagebox.askyesno("작업 완료", "엑셀을 확인하시겠습니까?"):
                subprocess.Popen([main_file], shell=True)
                
        except Exception as e:
            error_msg = f"환자 정보 업데이트 중 오류 발생: {str(e)}\n\n{traceback.format_exc()}"
            self.logger.error(error_msg)
            messagebox.showerror("오류", f"환자 정보 업데이트 중 오류 발생: {str(e)}")
        finally:
            self.enable_buttons()
    
    def update_sheets(self):
        """Update Excel sheets with new info or format"""
        self.logger.info("엑셀 시트 업데이트 시작...")
        
        # 초기화
        tables_to_update = []
        valid_tables = 0
        updated_tables = 0
        skipped_tables = 0
        error_tables = 0
        error_messages = []
        show_excel_confirmation = True  # 엑셀 확인 여부 창을 표시할지 여부
        
        try:
            # 메인 파일 찾기
            main_file = self.find_main_file()
            if not main_file:
                self.logger.error("메인 파일을 찾을 수 없습니다.")
                messagebox.showerror("오류", "메인 파일을 찾을 수 없습니다. 파일 감지를 먼저 실행해주세요.")
                self.enable_buttons()
                return "메인 파일을 찾을 수 없습니다."
            
            # 메인 파일 경로
            file_path = main_file  # 상대 경로 사용
            
            self.logger.info(f"메인 파일 경로: {file_path}")
            
            # 필요한 파일이 하나도 없는 경우 경고
            patients_file = self.find_file('patients')
            payment_file = self.find_file('paymentitems')
            
            if not patients_file and not payment_file:
                messagebox.showwarning("파일 없음", "Patients 파일과 PaymentItems 파일이 모두 없습니다. 파일 감지를 먼저 실행해주세요.")
                self.enable_buttons()
                return
                
            # Check if main file is accessible
            if not self.check_file_access(main_file):
                messagebox.showerror("오류", f"메인 파일이 열려있거나 접근할 수 없습니다.\n파일을 닫고 다시 시도해주세요: {main_file}")
                self.enable_buttons()
                return
                
            # Create backup
            try:
                backup_dir = os.path.join(os.path.dirname(main_file), "BACK UP")
                os.makedirs(backup_dir, exist_ok=True)
                backup_file = os.path.join(backup_dir, f"BACKUP_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{os.path.basename(main_file)}")
                self.logger.info(f"백업 폴더 생성/확인: {backup_dir}")
                self.logger.info(f"백업 파일 생성 시도: {backup_file}")
                shutil.copy2(main_file, backup_file)
                self.logger.info(f"메인 파일 백업 생성 완료: {backup_file}")
            except Exception as e:
                self.logger.error(f"백업 생성 중 오류 발생: {str(e)}")
                if not os.path.exists(main_file):
                    self.logger.error(f"메인 파일을 찾을 수 없음: {main_file}")
                    messagebox.showerror("오류", f"메인 파일을 찾을 수 없습니다: {main_file}")
                    self.enable_buttons()
                    return
                else:
                    self.logger.warning("백업 생성은 실패했지만 메인 파일은 존재함. 계속 진행합니다.")
            
            # Process Patients file first
            if patients_file:
                self.process_patients_file(main_file, patients_file)
            else:
                self.logger.warning("Patients 파일이 없습니다.")
                
            # Then process Payment Items file
            if payment_file:
                self.process_payment_items(main_file, payment_file)
            else:
                self.logger.warning("PaymentItems 파일이 없습니다.")
            
            # 환자 정보 업데이트 여부 확인
            if messagebox.askyesno("환자 정보 업데이트", "환자 정보를 업데이트하시겠습니까?"):
                self.update_patient_info()
                show_excel_confirmation = False  # 환자 정보 업데이트에서 이미 확인 창을 표시했으므로 여기서는 표시하지 않음
            
            # 시트 업데이트 후 가운데 정렬 적용 추가
            self.logger.info("모든 시트에 가운데 정렬 적용 중...")
            
            try:
                # 워크북 로드
                wb = load_workbook(file_path)
                center_alignment = Alignment(horizontal='center', vertical='center')
                
                # 각 워크시트 확인
                for sheet_name in wb.sheetnames:
                    sheet = wb[sheet_name]
                    self.logger.debug(f"시트 '{sheet_name}' 가운데 정렬 적용 중...")
                    
                    # 데이터가 있는 범위 확인
                    min_row = 1
                    min_col = 1
                    max_row = sheet.max_row
                    max_col = sheet.max_column
                    
                    # 모든 셀에 가운데 정렬 적용
                    align_count = 0
                    for row in range(min_row, max_row + 1):
                        for col in range(min_col, max_col + 1):
                            cell = sheet.cell(row=row, column=col)
                            # 모든 셀에 강제로 가운데 정렬 적용
                            cell.alignment = center_alignment
                            align_count += 1
                    
                    self.logger.info(f"시트 '{sheet_name}' 가운데 정렬 완료: {align_count}개 셀")
                
                # 수정된 워크북 저장
                wb.save(file_path)
                self.logger.info(f"가운데 정렬 적용 및 파일 저장 완료: {file_path}")
            
            except Exception as e:
                error_msg = f"가운데 정렬 적용 중 오류 발생: {str(e)}"
                self.logger.error(error_msg)
                self.logger.error(traceback.format_exc())
                error_messages.append(error_msg)
                
            # 파일 감지 다시 실행
            self.update_file_labels()
            
            # 환자 정보 업데이트에서 이미 확인 창을 표시하지 않았을 경우에만 표시
            if show_excel_confirmation and messagebox.askyesno("작업 완료", "엑셀을 확인하시겠습니까?"):
                subprocess.Popen([main_file], shell=True)
                
        except Exception as e:
            error_msg = f"표 업데이트 중 오류 발생: {str(e)}\n\n{traceback.format_exc()}"
            self.logger.error(error_msg)
            messagebox.showerror("오류", f"표 업데이트 중 오류 발생: {str(e)}")
        finally:
            self.enable_buttons()
        
        # 업데이트 결과 요약
        summary = "엑셀 파일 업데이트 결과 요약:\n"
        summary += f"- 테이블 처리: {len(tables_to_update)}개\n"
        summary += f"- 유효한 테이블: {valid_tables}개\n"
        summary += f"- 업데이트된 테이블: {updated_tables}개\n"
        summary += f"- 스킵된 테이블: {skipped_tables}개\n"
        summary += f"- 에러 발생 테이블: {error_tables}개\n"
        summary += f"- 모든 시트 가운데 정렬 완료\n"
        
        if error_messages:
            summary += "\n오류 세부 정보:\n"
            for error in error_messages:
                summary += f"- {error}\n"
        
        self.logger.info(summary)
        return summary
    
    def on_update_click(self):
        """Handle update button click"""
        # 버튼이 활성화되어 있다면 필요한 파일이 이미 감지된 상태
        # 바로 처리 진행
        self.disable_buttons("⏳ 처리 중...")
        threading.Thread(target=self.update_sheets, daemon=True).start()
        
    def on_patient_click(self):
        """Handle patient info update button click"""
        self.disable_buttons("⏳ 환자 정보 업데이트 중...")
        
        # 환자 정보 업데이트 실행 전 확인 다이얼로그 표시
        if messagebox.askyesno("환자 정보 업데이트", "환자 정보를 업데이트하시겠습니까?"):
            threading.Thread(target=self.update_patient_info, daemon=True).start()
        else:
            self.enable_buttons()
        
    def on_exit_click(self):
        """종료 버튼 클릭 처리"""
        self.logger.info("종료 버튼 클릭")
        # on_closing 메서드 호출하여 종료 처리
        self.on_closing()
    
    def disable_buttons(self, processing_text):
        """Disable all buttons during processing"""
        # 기능 버튼만 비활성화 (종료 버튼과 파일 감지 버튼은 제외)
        self.update_tables_btn.configure(state=tk.DISABLED)
        self.update_patient_btn.configure(state=tk.DISABLED)
        
        self.status_label.config(text=processing_text, fg="purple")
        self.progress_bar.start(10)  # 진행 표시줄 시작
        self.root.update()  # UI 업데이트 강제
            
    def enable_buttons(self):
        """Re-enable buttons after processing"""
        self.progress_bar.stop()  # 진행 표시줄 중지
        
        # 파일 감지 결과에 따라 버튼 상태 업데이트 및 상태 메시지 설정
        main_file = self.find_main_file()
        patients_file = self.find_file('patients')
        payment_items = self.find_file('paymentitems')
        
        # 파일 감지 결과에 따라 상태 메시지 설정
        if not main_file:
            self.status_label.config(text="⚠️ 메인 파일 없음", fg="red")
        elif not patients_file and not payment_items:
            self.status_label.config(text="⚠️ 입력 파일 없음", fg="orange")
        else:
            self.status_label.config(text="준비 완료", fg="black")
            
        # 파일 감지 및 버튼 상태 업데이트
        self.update_file_labels(show_alert=False)
        
        # 종료 버튼과 파일 감지 버튼은 항상 활성화 상태로 유지
        self.detect_button.config(text="🔎 파일 감지 업데이트", state=tk.NORMAL)
        self.exit_btn.config(text="🚪 종료", state=tk.NORMAL)
    
    def get_base_path(self):
        """
        Returns the base path for files
        """
        return ""  # 현재 디렉토리 (상대 경로)
    
    def read_csv_with_encoding(self, file_path, chunk_size=None):
        """
        CSV 파일을 다양한 인코딩으로 시도하여 읽음 (최적화 버전)
        
        Args:
            file_path: CSV 파일 경로
            chunk_size: 청크 단위로 읽을 때 사용할 크기 (대용량 파일용)
            
        Returns:
            DataFrame: 읽어들인 CSV 데이터
        """
        encodings = ['utf-8', 'cp949', 'euc-kr', 'latin1']
        
        # 먼저 파일 크기 확인
        file_size = os.path.getsize(file_path)
        # 파일이 5MB보다 크면 자동으로 청크 처리
        if file_size > 5 * 1024 * 1024 and chunk_size is None:  # 5MB
            chunk_size = 10000  # 기본 청크 크기
            self.logger.info(f"대용량 파일 감지 ({file_size/1024/1024:.1f}MB), 청크 처리 모드로 읽기")
        
        for encoding in encodings:
            try:
                # 청크 처리 필요한 경우
                if chunk_size:
                    chunks = []
                    for chunk in pd.read_csv(file_path, encoding=encoding, chunksize=chunk_size):
                        chunks.append(chunk)
                    df = pd.concat(chunks, ignore_index=True)
                else:
                    df = pd.read_csv(file_path, encoding=encoding)
                
                self.logger.info(f"파일 성공적으로 로드: {file_path} (인코딩: {encoding})")
                return df
            except UnicodeDecodeError:
                continue
            except pd.errors.EmptyDataError:
                self.logger.warning(f"빈 CSV 파일: {file_path}")
                return pd.DataFrame()
            except Exception as e:
                self.logger.error(f"파일 읽기 오류 ({encoding}): {str(e)}")
                continue
                
        self.logger.error(f"CSV 파일을 읽을 수 없음: {file_path}")
        return None
    
    def check_file_access(self, file_path):
        """Check if a file can be accessed (not locked by another process)"""
        if not os.path.exists(file_path):
            self.logger.error(f"파일이 존재하지 않습니다: {file_path}")
            return False
            
        try:
            # Try to open the file in read-write mode to check if it's locked
            with open(file_path, 'r+b') as f:
                return True
        except IOError:
            # File is locked by another process
            self.logger.warning(f"파일이 다른 프로세스에 의해 잠겨 있습니다: {file_path}")
            return False
    
    def find_table(self, table_name, workbook):
        """
        워크북에서 지정된 이름의 테이블을 찾는 함수 (캐싱 추가)
        """
        # 테이블 이름 캐싱 (동일 함수 호출 내에서 재사용)
        if not hasattr(self, '_table_cache'):
            self._table_cache = {}
        
        # 캐시에서 확인
        cache_key = f"{id(workbook)}_{table_name}"
        if cache_key in self._table_cache:
            return self._table_cache[cache_key]
            
        for sheet in workbook.worksheets:
            for table in sheet.tables.values():
                if table_name in table.name:
                    # 캐시에 저장
                    self._table_cache[cache_key] = table
                    self.logger.debug(f"테이블 캐시에 저장: {table_name}")
                    return table
                    
        return None

    def check_merged_cells(self, sheet, row, min_col, max_col):
        """병합된 셀이 있는지 확인하고, 있으면 True 반환"""
        # None 값 체크 강화
        if sheet is None or row is None or min_col is None or max_col is None:
            self.logger.warning("check_merged_cells: None 값이 전달되었습니다 (sheet, row, min_col, max_col 중 하나 이상)")
            return False
            
        # 타입 체크 및 변환
        try:
            row = int(row)
            min_col = int(min_col)
            max_col = int(max_col)
        except (ValueError, TypeError) as e:
            self.logger.warning(f"check_merged_cells: 타입 변환 실패 - row={row}, min_col={min_col}, max_col={max_col}, 오류: {str(e)}")
            return False
            
        # sheet.merged_cells가 None인 경우 체크
        if not hasattr(sheet, 'merged_cells') or sheet.merged_cells is None:
            self.logger.warning("check_merged_cells: sheet.merged_cells가 없거나 None입니다")
            return False
            
        # ranges 속성이 없거나 반복 불가능한 경우 체크
        try:
            if not hasattr(sheet.merged_cells, 'ranges') or not sheet.merged_cells.ranges:
                return False
        except Exception as e:
            self.logger.warning(f"check_merged_cells: merged_cells.ranges 접근 오류: {str(e)}")
            return False
        
        # 각 병합 범위 체크
        for merge_range in sheet.merged_cells.ranges:
            try:
                if merge_range is None or not str(merge_range):
                    continue
                    
                merge_range_str = str(merge_range)
                if ':' not in merge_range_str:
                    continue
                    
                merge_min_col, merge_min_row, merge_max_col, merge_max_row = range_boundaries(merge_range_str)
                
                # 값 타입 확인
                if None in (merge_min_col, merge_min_row, merge_max_col, merge_max_row):
                    continue
                    
                # 현재 행이 병합 범위에 포함되는지 확인
                if (merge_min_row <= row <= merge_max_row and 
                    not (merge_max_col < min_col or merge_min_col > max_col)):
                    return True
            except Exception as e:
                # 범위 파싱 오류 시 건너뛰기
                self.logger.debug(f"check_merged_cells: 병합 범위 '{merge_range}' 처리 중 오류: {str(e)}")
                continue
        return False

    def find_safe_row(self, sheet, start_row, min_col, max_col):
        """병합된 셀과 충돌하지 않는 안전한 행 찾기"""
        # 파라미터 체크
        if sheet is None:
            self.logger.warning("find_safe_row: sheet 파라미터가 None입니다.")
            return 1
            
        # None 값 체크 및 기본값 설정
        if start_row is None:
            self.logger.warning("find_safe_row: start_row가 None입니다. 기본값 1 사용.")
            start_row = 1
        
        if min_col is None:
            self.logger.warning("find_safe_row: min_col이 None입니다. 기본값 1 사용.")
            min_col = 1
            
        if max_col is None:
            self.logger.warning("find_safe_row: max_col이 None입니다. 기본값 10 사용.")
            max_col = 10
            
        # 타입 변환 시도
        try:
            start_row = int(start_row)
            min_col = int(min_col)
            max_col = int(max_col)
        except (ValueError, TypeError) as e:
            self.logger.warning(f"find_safe_row: 값 변환 오류 - start_row={start_row}, min_col={min_col}, max_col={max_col}, 오류: {str(e)}")
            # 안전한 기본값 사용
            return 1
            
        # 값 범위 검증
        if start_row < 1:
            self.logger.warning(f"find_safe_row: 잘못된 start_row 값 ({start_row}). 기본값 1 사용.")
            start_row = 1
            
        if min_col < 1:
            self.logger.warning(f"find_safe_row: 잘못된 min_col 값 ({min_col}). 기본값 1 사용.")
            min_col = 1
            
        if max_col < min_col:
            self.logger.warning(f"find_safe_row: 잘못된 max_col 값 ({max_col}, min_col={min_col}). min_col+5 사용.")
            max_col = min_col + 5
        
        row = start_row
        max_tries = 100  # 무한 루프 방지
        tries = 0
        
        while tries < max_tries:
            try:
                if not self.check_merged_cells(sheet, row, min_col, max_col):
                    return row
                row += 1
                tries += 1
            except Exception as e:
                self.logger.error(f"find_safe_row: 행 {row}에서 병합된 셀 확인 중 오류 발생: {str(e)}")
                return row  # 오류 발생 시 현재 행 반환
        
        self.logger.warning(f"find_safe_row: {max_tries}번 시도 후 안전한 행을 찾지 못했습니다. 현재 행을 사용합니다: {row}")
        return row

    def copy_cell_style(self, source_cell, target_cell):
        """Copy cell style from source to target cell"""
        if source_cell.has_style:
            target_cell.font = copy(source_cell.font)
            target_cell.fill = copy(source_cell.fill)
            target_cell.border = copy(source_cell.border)
            target_cell.alignment = copy(source_cell.alignment)
            target_cell.number_format = source_cell.number_format
            target_cell.protection = copy(source_cell.protection)

    def show_help(self):
        """도움말 표시"""
        help_window = tk.Toplevel(self.root)
        help_window.title("프로그램 도움말")
        help_window.geometry("700x500")
        help_window.configure(bg="#FDF6E3")  # 베이지색 (이전: #FDF6F0)
        
        # 창을 모달로 설정 (부모 창 조작 방지)
        help_window.grab_set()
        
        # 메인 콘텐츠 프레임
        content_frame = ttk.Frame(help_window, padding=15)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # 제목
        title = ttk.Label(content_frame, text="🐱 KDOC 마크7 V3.1 사용 설명서 🐱", 
                         font=('Arial', 16, 'bold'))
        title.pack(pady=(0, 15))
        
        # 스크롤 가능한 텍스트 영역을 위한 프레임
        scroll_frame = ttk.Frame(content_frame)
        scroll_frame.pack(fill=tk.BOTH, expand=True)
        
        # 텍스트 영역 생성
        text_area = tk.Text(
            scroll_frame,
            wrap=tk.WORD,
            bg="#FFF8E1",  # 크림색 배경
            font=('Arial', 11))
        text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # 스크롤바 추가
        scrollbar = ttk.Scrollbar(scroll_frame, command=text_area.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        text_area.config(yscrollcommand=scrollbar.set)
        
        # 도움말 내용
        help_text = """
🐱 KDOC 마크7 V3.1 사용 설명서 🐱

1. 프로그램이 뭐예요?
   - 환자 정보와 결제 내역을 정리해주는 프로그램입니다.
   - 엑셀 파일과 CSV 파일의 데이터를 자동으로 합쳐줍니다.
   - 같은 내용이 중복으로 들어가는 것을 방지해줍니다.

2. 필요한 파일은 뭐가 있나요?
   - 필수 파일: '회원-sales_공란.xlsx' (메인 파일)
   - 선택 파일: 'Patients.csv' (환자 정보)
   - 선택 파일: 'PaymentItems.csv' (결제 내역)
   - 모든 파일은 프로그램이 있는 폴더에 넣어주세요.

3. 어떻게 사용하나요?
   ① 파일 새로고침 버튼을 눌러주세요
      - 프로그램이 필요한 파일을 찾아서 보여줍니다.
      - 파일이 제대로 있는지 확인할 수 있습니다.
   
   ② 표 업데이트 버튼을 눌러주세요
      - 환자 정보나 결제 내역을 메인 파일에 넣어줍니다.
      - 같은 내용이 있으면 자동으로 건너뜁니다.
      - 결과는 알림창에서 확인할 수 있습니다.
   
   ③ 환자 정보 업데이트 버튼을 눌러주세요
      - 환자 정보를 자동으로 정리해줍니다.
      - 이름, 나이, 성별, 지역 정보가 업데이트됩니다.

4. 주요 기능 설명:
   📋 중복 체크:
      - 같은 환자 정보가 여러 번 들어가는 것을 방지합니다.
      - 이름, 등록 날짜, 주소를 비교합니다.
      - 특별한 환자나 의사는 중복 체크에서 제외됩니다.
   
   🔄 데이터 정리:
      - 이름의 대소문자와 공백을 깔끔하게 정리합니다.
      - 날짜 형식을 통일합니다 (예: 2024-03-15).
      - 특수문자와 공백을 정리합니다.
   
   📊 결과 확인:
      - 처리된 건수, 중복 건수, 제외된 건수를 보여줍니다.
      - 상세한 결과도 확인할 수 있습니다.

5. 파일 관리:
   - 'BACK UP' 폴더: 원본 파일이 자동으로 저장됩니다.
   - 'DONE' 폴더: 처리된 파일이 이동됩니다.
   - 'SKIPPED' 폴더: 중복된 파일이 이동됩니다.

6. 로그 확인:
   - 화면 아래에서 작업 내용을 확인할 수 있습니다.
   - 디버그 모드를 켜면 더 자세한 내용을 볼 수 있습니다.
   - 문제가 생겼을 때 로그를 보면 원인을 찾을 수 있습니다.

7. 알림 기능:
   - 작업이 끝나면 결과를 알려줍니다.
   - 중복된 내용이 있으면 상세 정보를 보여줍니다.
   - 제외된 내용도 확인할 수 있습니다.

8. 주의할 점:
   - 파일을 처리하는 동안 프로그램을 끄지 마세요.
   - 큰 파일은 처리하는데 시간이 걸릴 수 있습니다.
   - 중요한 작업 후에는 파일을 직접 확인해보세요.

9. 문제가 생겼을 때:
   - 파일이 안 보여요: 파일 이름과 확장자를 확인해주세요.
   - 오류가 발생했어요: 로그 메시지를 확인해주세요.
   - 이상한 동작이에요: 디버그 모드를 켜서 확인해주세요.
   - 프로그램이 멈췄어요: 잠시 기다려주세요. 큰 파일은 시간이 걸립니다.

10. 새로운 기능 (V3.1):
    - 더 정확한 중복 체크
    - 자세한 작업 내역 확인
    - 편리한 알림창
    - 더 빠른 속도와 깔끔한 화면

궁금한 점이 있으시면 개발자에게 물어보세요!
"""
        
        text_area.insert(tk.END, help_text)
        text_area.config(state="disabled")  # 읽기 전용으로 설정
        
        # 닫기 버튼
        close_btn = tk.Button(
            content_frame,
            text="닫기",
            font=("Arial", 11),
            bg="#F5CBA7",  # 황토색 버튼 (이전: #FFE1E1)
            fg="#5D4037",
            padx=10,
            pady=5,
            relief="flat",
            cursor="hand2",
            command=help_window.destroy
        )
        close_btn.pack(pady=15)
        
        # 창을 화면 중앙에 표시
        help_window.update_idletasks()
        width = help_window.winfo_width()
        height = help_window.winfo_height()
        x = (help_window.winfo_screenwidth() // 2) - (width // 2)
        y = (help_window.winfo_screenheight() // 2) - (height // 2)
        help_window.geometry(f"{width}x{height}+{x}+{y}")
        
        # 부모 창보다 항상 위에 표시
        help_window.transient(self.root)
        help_window.focus_set()

    # 날짜 처리 유틸리티 함수 추가
    def format_date(self, date_value, include_time=False, excel_format=False):
        """다양한 형식의 날짜를 표준 형식으로 변환하는 유틸리티 함수
        
        Args:
            date_value: 변환할 날짜 값 (문자열, datetime 등)
            include_time: 시간을 포함할지 여부
            excel_format: 엑셀 한글 형식으로 반환할지 여부 (True: 2024년 3월 15일)
            
        Returns:
            formatted_date: 형식화된 날짜 문자열 또는 None (변환 실패 시)
        """
        if date_value is None:
            return None
            
        try:
            # 이미 datetime 객체인 경우
            if isinstance(date_value, datetime):
                dt = date_value
            else:
                # pandas를 통한 날짜 변환
                dt = pd.to_datetime(date_value, errors='coerce')
                if pd.isna(dt):
                    return date_value  # 변환 실패 시 원본 반환
            
            # 시간이 없는 경우 현재 시간 추가 (include_time=True인 경우만)
            if include_time and dt.hour == 0 and dt.minute == 0:
                dt = dt.replace(hour=datetime.now().hour, minute=datetime.now().minute)
            
            # 형식에 맞게 출력
            if excel_format:
                return dt.strftime("%Y년 %m월 %d일")
            elif include_time:
                return dt.strftime("%Y-%m-%d %H:%M")
            else:
                return dt.strftime("%Y-%m-%d")
                
        except Exception as e:
            self.logger.warning(f"날짜 변환 실패: {date_value}, 오류: {str(e)}")
            return date_value  # 변환 실패 시 원본 반환

    def show_detailed_result(self, title, summary, details=None):
        """상세 결과를 보여주는 다이얼로그 표시"""
        result_window = tk.Toplevel()
        result_window.title(title)
        result_window.geometry("600x500")
        
        # 창을 화면 중앙에 위치
        window_width = 600
        window_height = 500
        screen_width = result_window.winfo_screenwidth()
        screen_height = result_window.winfo_screenheight()
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2
        result_window.geometry(f"{window_width}x{window_height}+{x}+{y}")
        
        # 메인 프레임
        main_frame = ttk.Frame(result_window)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # 요약 정보 표시
        summary_label = ttk.Label(
            main_frame, 
            text=summary,
            wraplength=550,
            justify=tk.LEFT
        )
        summary_label.pack(fill=tk.X, pady=(0, 10))
        
        if details:
            # 스크롤 가능한 텍스트 영역을 위한 프레임
            text_frame = ttk.Frame(main_frame)
            text_frame.pack(fill=tk.BOTH, expand=True)
            
            # 스크롤바 생성
            scrollbar = ttk.Scrollbar(text_frame)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # 텍스트 위젯 생성
            text_widget = tk.Text(
                text_frame,
                wrap=tk.WORD,
                yscrollcommand=scrollbar.set,
                height=15,
                background='#FFF3E0'  # 연한 크림색 (이전: #F5F5F5)
            )
            text_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            
            # 스크롤바와 텍스트 위젯 연결
            scrollbar.config(command=text_widget.yview)
            
            # 상세 정보 추가
            text_widget.insert(tk.END, details)
            text_widget.config(state=tk.DISABLED)  # 읽기 전용으로 설정
            
            # 마우스 휠 이벤트 바인딩
            def on_mousewheel(event):
                text_widget.yview_scroll(int(-1 * (event.delta / 120)), "units")
            text_widget.bind("<MouseWheel>", on_mousewheel)
        
        # 확인 버튼
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))
        
        ok_button = ttk.Button(
            button_frame,
            text="확인",
            command=result_window.destroy,
            width=15
        )
        ok_button.pack(pady=(10, 0))
        
        # 창을 모달로 설정
        result_window.transient(self.root)
        result_window.grab_set()
        
        # 창이 닫힐 때까지 대기
        self.root.wait_window(result_window)

    def on_closing(self):
        """프로그램 종료 처리"""
        if messagebox.askokcancel("종료", "프로그램을 종료하시겠습니까?"):
            try:
                # 종료 메시지 출력
                self.logger.info("프로그램 종료")
                
                # stdout에 안전하게 출력 시도
                try:
                    if hasattr(sys, 'stdout') and sys.stdout and hasattr(sys.stdout, 'write'):
                        sys.stdout.write("프로그램이 종료됩니다.\n")
                        if hasattr(sys.stdout, 'flush'):
                            sys.stdout.flush()
                except Exception:
                    pass
                
                # 진행 표시줄 중지
                try:
                    if hasattr(self, 'progress_bar'):
                        self.progress_bar.stop()
                except Exception:
                    pass
                
                # 리디렉션 해제 - 안전하게 처리
                if hasattr(self, 'stdout_redirector'):
                    try:
                        if hasattr(self.stdout_redirector, 'original_stdout'):
                            sys.stdout = self.stdout_redirector.original_stdout
                    except Exception:
                        # 기본 출력으로 복원
                        sys.stdout = sys.__stdout__
                        
                if hasattr(self, 'stderr_redirector'):
                    try:
                        if hasattr(self.stderr_redirector, 'original_stdout'):
                            sys.stderr = self.stderr_redirector.original_stdout
                    except Exception:
                        # 기본 출력으로 복원
                        sys.stderr = sys.__stderr__
            except Exception as e:
                print(f"종료 중 오류 발생: {str(e)}")
            finally:
                # 즉시 강제 종료
                os._exit(0)

    def center_window(self):
        """창을 화면 중앙에 배치합니다"""
        self.root.update_idletasks()
        width = self.root.winfo_width()
        height = self.root.winfo_height()
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")
    
    def find_main_file(self):
        """메인 Excel/CSV 파일을 찾습니다('회원-sales'로 시작하는 파일)"""
        for filename in os.listdir('.'):
            lower_name = filename.lower()
            if lower_name.startswith('회원-sales') and (lower_name.endswith('.xlsx') or lower_name.endswith('.csv')):
                print(f"메인 파일 찾음: {filename}")
                return filename
        print("메인 파일을 찾을 수 없습니다.")
        return None
    
    def find_file(self, prefix):
        """특정 접두사로 시작하는 Excel/CSV 파일을 찾습니다"""
        for filename in os.listdir('.'):
            lower_name = filename.lower()
            if lower_name.startswith(prefix.lower()) and (lower_name.endswith('.xlsx') or lower_name.endswith('.csv')):
                print(f"{prefix} 파일 찾음: {filename}")
                return filename
        print(f"{prefix} 파일을 찾을 수 없습니다.")
        return None

# Run the application
if __name__ == "__main__":
    try:
        # 전역 예외 핸들러 설정 
        sys.excepthook = custom_excepthook
        
        # PyInstaller 환경인지 확인
        is_frozen = getattr(sys, 'frozen', False)
        
        # 로그 디렉토리 생성
        log_dir = "logs"
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)
            
        # 오늘 날짜로 로그 파일 이름 생성
        log_file = os.path.join(log_dir, f"app_log_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt")
        
        # 루트 로거 설정
        root_logger = logging.getLogger()
        root_logger.handlers = []  # 기존 핸들러 모두 제거
        
        # 패키징된 환경에서는 GUI 로깅을 비활성화하고 파일 로깅만 사용
        if is_frozen:
            # 파일 핸들러 추가 - 디버그 레벨로 설정
            file_handler = logging.FileHandler(log_file, encoding='utf-8')
            file_handler.setLevel(logging.DEBUG)
            formatter = logging.Formatter('[%(asctime)s] %(levelname)s: %(message)s', datefmt='%H:%M:%S')
            file_handler.setFormatter(formatter)
            root_logger.addHandler(file_handler)
            root_logger.setLevel(logging.DEBUG)
            
            # 콘솔 출력은 안전한 객체로 대체
            class SafeWriter:
                def write(self, s): pass
                def flush(self): pass
                def isatty(self): return False
            
            # 표준 출력/에러 스트림 교체
            sys.stdout = SafeWriter()
            sys.stderr = SafeWriter()
            
            # 시작 메시지 기록
            logging.info(f"애플리케이션 시작 - 로그 파일: {log_file}")
        else:
            # 개발 환경에서는 콘솔 로그도 활성화
            console_handler = logging.StreamHandler()
            console_handler.setLevel(logging.INFO)
            formatter = logging.Formatter('[%(asctime)s] %(levelname)s: %(message)s', datefmt='%H:%M:%S')
            console_handler.setFormatter(formatter)
            root_logger.addHandler(console_handler)
            
            # 파일 핸들러도 추가
            file_handler = logging.FileHandler(log_file, encoding='utf-8')
            file_handler.setLevel(logging.DEBUG)
            file_handler.setFormatter(formatter)
            root_logger.addHandler(file_handler)
            
            root_logger.setLevel(logging.DEBUG)
        
        logging.info("Starting Excel Processor application...")
        
        # Check for required libraries
        missing_libs = []
        try:
            logging.info("Checking for openpyxl...")
            import openpyxl
            logging.info("openpyxl found.")
        except ImportError:
            missing_libs.append("openpyxl")
            logging.error("openpyxl not found.")
        
        try:
            logging.info("Checking for pandas...")
            import pandas
            logging.info("pandas found.")
        except ImportError:
            missing_libs.append("pandas")
            logging.error("pandas not found.")
        
        if missing_libs:
            logging.error("Missing required libraries:")
            for lib in missing_libs:
                logging.error(f"  - {lib}")
            logging.error("\nPlease install them using:")
            logging.error(f"pip install {' '.join(missing_libs)}")
            sys.exit(1)
        
        # GUI 이중화 방지
        try:
            root_check = tk.Tk()
            root_check.withdraw()
            root_check.destroy()
        except:
            pass
            
        logging.info("Initializing ExcelProcessor...")
        app = ExcelProcessor()
        logging.info("Starting main loop...")
        
        # frozen 환경이 아닐 경우에만 GUI 로그 핸들러 생성
        if not is_frozen:
            app.create_gui_log_handler()
            
        app.root.mainloop()
    except Exception as e:
        logging.error(f"Error initializing application: {str(e)}")
        logging.error(traceback.format_exc())

# 파일 실행 시작 부분 제거 (중복 main 블록)

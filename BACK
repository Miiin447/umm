import os
import shutil
import logging
from datetime import datetime, timedelta, timezone
import pandas as pd
from openpyxl import load_workbook
from openpyxl.utils import range_boundaries, get_column_letter
import re
from copy import copy
from openpyxl.styles import Border, Side, PatternFill
from tkinter import messagebox
from collections import Counter
from openpyxl.worksheet.filters import AutoFilter
import pytz
from openpyxl.chart import LineChart, Reference

class ExcelBackend:
    def __init__(self):
        # 로거 설정
        self.logger = logging.getLogger("ExcelBackend")
        self.logger.setLevel(logging.DEBUG)
        
        # 파일 핸들러 추가
        log_dir = "logs"
        os.makedirs(log_dir, exist_ok=True)
        file_handler = logging.FileHandler(
            os.path.join(log_dir, f'excel_backend_{datetime.now().strftime("%Y%m%d")}.log'),
            encoding='utf-8'
        )
        file_handler.setLevel(logging.DEBUG)
        
        # 콘솔 핸들러 추가
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)
        
        # 포맷터 설정
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)
        
        # 핸들러 추가
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
        
        # 제외할 키워드 목록
        self.excluded_keywords = {'heale', 'tele', 'develop', 'test', 'patient', 'kdoc', 'k-doc', 'k- doc'}
        self.logger.info("ExcelBackend 초기화 완료")

    def should_exclude_row(self, row_data):
        """행을 제외해야 하는지 확인하는 함수"""
        # pandas Series를 딕셔너리로 변환
        if isinstance(row_data, pd.Series):
            row_dict = row_data.to_dict()
        else:
            row_dict = row_data
            
        for value in row_dict.values():
            if isinstance(value, str):
                value_lower = value.lower()
                if any(keyword in value_lower for keyword in self.excluded_keywords):
                    return True
        return False

    def standardize_value(self, val, preserve_format=False):
        if val is None:
            return ""
        try:
            dt = pd.to_datetime(val, errors='coerce')
            if pd.notnull(dt):
                return f"{dt.year}년 {dt.month}월 {dt.day}일"
        except:
            pass
        
        # 이름이나 의사명인 경우 원본 형식 유지
        if preserve_format:
            return str(val).strip()
            
        return re.sub(r'[^a-zA-Z0-9가-힣]', '', str(val).lower())

    def standardize_date(self, date_value):
        if not date_value or pd.isna(date_value):
            return None
        try:
            if isinstance(date_value, datetime):
                return f"{date_value.year}년 {date_value.month}월 {date_value.day}일"
            if isinstance(date_value, str):
                date_str = str(date_value).strip()
                if "년" in date_str and "월" in date_str and "일" in date_str:
                    return date_str
                # 한글 날짜 형식 처리 (예: "4월 1, 2024")
                if "월" in date_str and "," in date_str:
                    try:
                        month = int(date_str.split("월")[0])
                        day = int(date_str.split(",")[0].split("월")[1].strip())
                        year = int(date_str.split(",")[1].strip())
                        return f"{year}년 {month}월 {day}일"
                    except Exception as e:
                        self.logger.warning(f"한글 날짜 형식 변환 실패: {date_str} -> {str(e)}")
                # 숫자 형식 날짜 처리 (예: 2024-04-01)
                try:
                    dt = pd.to_datetime(date_str, errors='coerce')
                    if pd.notnull(dt):
                        return f"{dt.year}년 {dt.month}월 {dt.day}일"
                except:
                    pass
            return None
        except Exception as e:
            self.logger.warning(f"날짜 정규화 실패: {date_value} -> {str(e)}")
            return None

    def check_file_access(self, file_path):
        if not os.path.exists(file_path):
            self.logger.error(f"파일이 존재하지 않습니다: {file_path}")
            return False
        try:
            with open(file_path, 'r+b') as f:
                return True
        except IOError:
            self.logger.warning(f"파일이 다른 프로세스에 의해 잠겨 있습니다: {file_path}")
            return False

    def find_table(self, table_name, workbook_or_sheet):
        """테이블 찾기 함수 개선 (워크북 또는 시트 모두 지원)"""
        self.logger.info(f"테이블 찾기 시작: {table_name}")
        # 시트 객체가 들어오면 그 시트에서만 찾기
        if hasattr(workbook_or_sheet, 'tables') and hasattr(workbook_or_sheet, 'title'):
            for table in workbook_or_sheet.tables.values():
                self.logger.debug(f"테이블 이름: {table.name}")
                if table_name in table.name:
                    self.logger.info(f"테이블 찾음: {table.name} (시트: {workbook_or_sheet.title})")
                    return table
            self.logger.warning(f"테이블을 찾을 수 없음: {table_name}")
            return None
        # 워크북 객체면 전체 시트에서 찾기
        for sheet in workbook_or_sheet.worksheets:
            self.logger.debug(f"시트 검색 중: {sheet.title}")
            for table in sheet.tables.values():
                self.logger.debug(f"테이블 이름: {table.name}")
                if table_name in table.name:
                    self.logger.info(f"테이블 찾음: {table.name} (시트: {sheet.title})")
                    return table
        self.logger.warning(f"테이블을 찾을 수 없음: {table_name}")
        return None

    def process_patients_file(self, main_file, patients_file):
        try:
            self.logger.info(f"환자 파일 처리 시작: {patients_file}")
            
            wb = load_workbook(main_file)
            patients_df = pd.read_csv(patients_file)
            self.logger.debug(f"CSV 파일 로드 완료: {len(patients_df)} 행")
            self.logger.debug(f"CSV 컬럼 목록: {patients_df.columns.tolist()}")

            # === 한글/영문 헤더 매핑 ===
            header_mapping = {
                "Date of registration": "등록 날짜",
                "Name": "이름",
                "Phone number": "전화번호",
                "Date of birth": "생년월일",
                "Gender": "성별",
                "Email": "이메일",
                "Patient type": "환자 유형",
                "Policy": "정책",
                "Marketing": "마케팅",
                "Address": "주소",
                "Address 2": "주소2",
                "City": "도시",
                "State": "현재 있는 주",
                "Zip code": "우편번호",
                # 필요시 추가
            }
            # 영문 헤더가 있으면 한글로 변환
            rename_dict = {col: header_mapping[col] for col in patients_df.columns if col in header_mapping}
            if rename_dict:
                self.logger.info(f"헤더 영→한 변환: {rename_dict}")
                patients_df.rename(columns=rename_dict, inplace=True)
                self.logger.info(f"헤더 변환 후 컬럼: {patients_df.columns.tolist()}")
            
            # 제외된 행 수 카운트
            excluded_count = 0
            
            # 제외 키워드가 포함된 행 제거
            for idx, row in patients_df.iterrows():
                if self.should_exclude_row(row):
                    self.logger.info(f"제외 키워드가 포함된 행 제거: {row.get('이름', '')}")
                    patients_df = patients_df.drop(idx)
                    excluded_count += 1
            
            self.logger.info(f"제외된 행 수: {excluded_count}")
            
            # 등록 날짜 형식 통일
            if '등록 날짜' in patients_df.columns:
                patients_df['등록 날짜'] = patients_df['등록 날짜'].apply(self.standardize_date)
                self.logger.info("등록 날짜 형식 통일 완료")
            
            table = self.find_table("회원자동", wb)
            if not table:
                self.logger.error("회원자동 테이블을 찾을 수 없음")
                return {"success": False, "msg": "회원자동 테이블 없음"}
            
            patients_sheet = None
            for sheet in wb.worksheets:
                if table in sheet.tables.values():
                    patients_sheet = sheet
                    break
            
            if not patients_sheet:
                self.logger.error("회원자동 테이블이 있는 시트를 찾을 수 없음")
                return {"success": False, "msg": "회원자동 테이블이 있는 시트를 찾을 수 없음"}

            min_col, min_row, max_col, max_row = range_boundaries(table.ref)
            excel_headers = {}
            col_to_letter = {}
            
            for col in range(min_col, max_col + 1):
                cell_value = patients_sheet.cell(row=min_row, column=col).value
                if cell_value:
                    header_name = str(cell_value).strip()
                    excel_headers[header_name] = col
                    col_to_letter[header_name] = get_column_letter(col)
                    self.logger.debug(f"헤더 매핑: {header_name} -> 열 {col} (열 문자: {get_column_letter(col)})")
            
            # 중복 데이터 체크를 위한 컬럼 찾기
            name_col = excel_headers.get("이름")
            dob_col = excel_headers.get("생년월일")
            reg_date_col = excel_headers.get("등록 날짜")
            state_col = excel_headers.get("주")
            age_range_col = excel_headers.get("Age_Range") or excel_headers.get("연령대")
            age_col = excel_headers.get("Age") or excel_headers.get("나이")
            gender_col = excel_headers.get("성별")

            # 컬럼 찾기 상세 로깅
            self.logger.info("\n=== 회원자동 테이블 컬럼 정보 ===")
            self.logger.info(f"엑셀 헤더 전체 목록: {excel_headers}")
            self.logger.info(f"이름 열: {name_col} ({col_to_letter.get('이름', '?')})")
            self.logger.info(f"등록 날짜 열: {reg_date_col} ({col_to_letter.get('등록 날짜', '?')})")
            self.logger.info(f"주 열: {state_col} ({col_to_letter.get('주', '?')})")
            self.logger.info(f"생년월일 열: {dob_col} ({col_to_letter.get('생년월일', '?')})")
            self.logger.info(f"연령대 열: {age_range_col} ({col_to_letter.get('Age_Range', col_to_letter.get('연령대', '?'))})")
            self.logger.info(f"나이 열: {age_col} ({col_to_letter.get('Age', col_to_letter.get('나이', '?'))})")
            self.logger.info(f"성별 열: {gender_col} ({col_to_letter.get('성별', '?')})")
            
            # 기존 데이터 수집 (이름, 생년월일, 성별, 주만으로 중복 체크)
            existing_records = set()
            for row in range(min_row + 1, max_row + 1):
                name = self.standardize_value(patients_sheet.cell(row=row, column=name_col).value, preserve_format=True)
                dob = self.standardize_value(patients_sheet.cell(row=row, column=dob_col).value, preserve_format=True) if dob_col else ""
                gender = self.standardize_value(patients_sheet.cell(row=row, column=gender_col).value, preserve_format=True) if gender_col else ""
                state = self.standardize_value(patients_sheet.cell(row=row, column=state_col).value, preserve_format=True) if state_col else ""
                record = (name, dob, gender, state)
                existing_records.add(record)
                self.logger.debug(f"기존 데이터 수집(이름,생년월일,성별,주): {record}")

            added_count = 0
            skipped_count = 0
            
            for idx, row in patients_df.iterrows():
                name = self.standardize_value(row.get("이름", ""), preserve_format=True)
                dob = self.standardize_value(row.get("생년월일", ""), preserve_format=True)
                gender = self.standardize_value(row.get("성별", ""), preserve_format=True)
                state = self.standardize_value(row.get("현재 있는 주", ""), preserve_format=True)
                record = (name, dob, gender, state)
                if record in existing_records:
                    self.logger.info(f"중복 데이터 건너뛰기: {name} (이름,생년월일,성별,주 동일)")
                    skipped_count += 1
                    continue
                
                self.logger.info(f"\n=== 새로운 환자 데이터 처리 ===")
                self.logger.info(f"이름: {name}")
                self.logger.info(f"생년월일: {dob}")
                self.logger.info(f"주: {state}")
                self.logger.info(f"성별: {gender}")
                    
                max_row += 1
                for header, col in excel_headers.items():
                    value = row.get(header, "")
                    # '주' 컬럼에 '현재 있는 주' 데이터 매핑
                    if header == "주":
                        value = row.get("현재 있는 주", "")
                    cell = patients_sheet.cell(row=max_row, column=col)
                    
                    if header == "등록 날짜" and value:
                        cell.value = value  # 이미 표준화된 형식
                    else:
                        cell.value = value
                    
                    if max_row > min_row + 1:
                        try:
                            source_cell = patients_sheet.cell(row=min_row + 1, column=col)
                            if source_cell.has_style:
                                cell.font = copy(source_cell.font)
                                cell.fill = copy(source_cell.fill)
                                cell.border = copy(source_cell.border)
                                cell.alignment = copy(source_cell.alignment)
                        except Exception as e:
                            self.logger.warning(f"셀 스타일 복사 실패 (행: {max_row}, 열: {col}): {str(e)}")
                
                # 나이와 연령대 계산 및 추가
                if dob_col:  # 생년월일 컬럼이 있는 경우
                    birth_date = patients_sheet.cell(row=max_row, column=dob_col).value
                    self.logger.info(f"\n=== 나이/연령대 계산 시작 ===")
                    self.logger.info(f"생년월일 데이터: {birth_date}")
                    
                    # 나이 계산
                    age = None
                    if birth_date and not pd.isna(birth_date):
                        age = self.calculate_age_from_birthdate(birth_date)
                        self.logger.info(f"생년월일로 계산된 나이: {age}")
                    
                    # 나이와 연령대 입력
                    if age is not None:
                        # 나이 입력
                        if age_col:
                            age_cell = patients_sheet.cell(row=max_row, column=age_col)
                            age_cell.value = age  # 숫자 그대로 입력
                            self.logger.info(f"나이 입력 완료: {age}세 (열: {age_col})")
                        
                        # 연령대 입력
                        if age_range_col:
                            age_range = self.get_age_range(age)
                            self.logger.info(f"계산된 연령대: {age_range}")
                            age_range_cell = patients_sheet.cell(row=max_row, column=age_range_col)
                            age_range_cell.value = age_range  # 문자열 그대로 입력
                            self.logger.info(f"연령대 입력 완료: {age_range} (열: {age_range_col})")
                    else:
                        self.logger.warning("나이를 계산할 수 없어 연령대를 입력하지 않음")
                
                added_count += 1
                existing_records.add(record)
                self.logger.info(f"환자 데이터 추가 완료 (행: {max_row})")

            # 빈 행 삭제
            empty_rows = []
            for row in range(min_row + 1, max_row + 1):
                is_empty = True
                for col in range(min_col, max_col + 1):
                    if patients_sheet.cell(row=row, column=col).value:
                        is_empty = False
                        break
                if is_empty:
                    empty_rows.append(row)

            # 다른 행이 없는 경우에만 첫 번째 행 보존
            if len(empty_rows) == max_row - min_row:
                empty_rows.remove(min_row + 1)  # 첫 번째 행은 보존

            # 빈 행 삭제 (역순으로 삭제하여 인덱스 변화 방지)
            for row in sorted(empty_rows, reverse=True):
                patients_sheet.delete_rows(row)
                max_row -= 1

            if added_count > 0:
                table.ref = f"{get_column_letter(min_col)}{min_row}:{get_column_letter(max_col)}{max_row}"
            wb.save(main_file)
            
            self.logger.info(f"환자 처리 완료: {added_count}명 추가, {skipped_count}명 중복, {excluded_count}명 제외")
            return {"success": True, "msg": f"환자 {added_count}명 추가, 중복 {skipped_count}명, 제외 {excluded_count}명"}
        except Exception as e:
            self.logger.error(f"환자 파일 처리 중 오류 발생: {str(e)}", exc_info=True)
            return {"success": False, "msg": str(e)}

    def process_PaymentItems_items(self, main_file, PaymentItems_file):
        try:
            self.logger.info(f"결제 항목 파일 처리 시작: {PaymentItems_file}")
            
            wb = load_workbook(main_file)
            self.logger.debug("엑셀 파일 로드 완료")
            
            encodings = ['utf-8', 'cp949', 'euc-kr', 'utf-16']
            df = None
            
            for encoding in encodings:
                try:
                    self.logger.debug(f"CSV 파일 읽기 시도 (인코딩: {encoding})")
                    df = pd.read_csv(PaymentItems_file, encoding=encoding)
                    self.logger.info(f"CSV 파일 로드 성공 (인코딩: {encoding})")
                    break
                except UnicodeDecodeError:
                    continue
                except Exception as e:
                    self.logger.error(f"CSV 파일 읽기 실패 (인코딩: {encoding}): {str(e)}")
                    continue
            
            if df is None:
                self.logger.error("지원되는 인코딩으로 CSV 파일을 읽을 수 없음")
                return {"success": False, "msg": "CSV 파일을 읽을 수 없음"}
            
            self.logger.info(f"CSV 컬럼 목록: {df.columns.tolist()}")
            
            # 필요한 컬럼만 매핑
            column_mapping = {
                # 영문 → 한글 매핑
                'Date': '날짜',
                'Doctor id': '의료인 ID',
                'Doctor name': '진단 의사명',
                'Amount': '양',
                'For doctor': '의사용',
                'Currency': '통화',
                'Voucher': '바우처',
                'Patient': '환자 명',
                'Description': '설명',
                # 기존 한글 매핑도 유지
                '날짜': '등록날짜',  # 기존 코드와 호환
                '환자': '환자 명',
                '의료인 이름': '진단 의사명',
            }
            # 영문 헤더가 있으면 한글로 변환
            rename_dict = {col: column_mapping[col] for col in df.columns if col in column_mapping}
            if rename_dict:
                self.logger.info(f"결제파일 헤더 영→한 변환: {rename_dict}")
                df.rename(columns=rename_dict, inplace=True)
                self.logger.info(f"헤더 변환 후 컬럼: {df.columns.tolist()}")
            # '날짜' 컬럼이 있으면 '등록날짜'로 한 번 더 변환
            if '날짜' in df.columns:
                df.rename(columns={'날짜': '등록날짜'}, inplace=True)
                self.logger.info(f"'날짜' → '등록날짜' 컬럼명 변환 적용: {df.columns.tolist()}")

            # 날짜 데이터 전처리 (매핑 후, '등록날짜' 또는 '날짜' 기준)
            date_col = None
            if '등록날짜' in df.columns:
                date_col = '등록날짜'
            elif '날짜' in df.columns:
                date_col = '날짜'
            if date_col:
                self.logger.info(f"날짜 파싱 기준 컬럼: {date_col}")
                def parse_english_date(date_str):
                    try:
                        return pd.to_datetime(date_str)
                    except Exception:
                        return None
                df['원본_날짜'] = df[date_col].apply(parse_english_date)
                # 날짜가 없는 행 확인
                null_dates = df['원본_날짜'].isnull()
                if null_dates.any():
                    self.logger.warning(f"날짜가 없는 행 수: {null_dates.sum()}")
                    for idx in df[null_dates].index:
                        self.logger.warning(f"행 {idx + 2}의 원본 날짜 데이터: {df.loc[idx, date_col]}")
                # 표시용 날짜 형식으로 변환 (시간 포함)
                df[date_col] = df['원본_날짜'].apply(
                    lambda x: x.strftime('%Y년 %m월 %d일 %H:%M:%S') if pd.notnull(x) else None
                )
                # 날짜 컬럼이 비어있는 행 제거
                df = df.dropna(subset=[date_col])
                self.logger.info(f"날짜가 있는 행만 유지: {len(df)}행")
                self.logger.info("날짜 컬럼 처리 완료")
            
            # 데이터 검증
            required_columns = ['등록날짜', '환자 명', '진단 의사명']
            missing_columns = [col for col in required_columns if col not in df.columns]
            if missing_columns:
                self.logger.error(f"필수 컬럼이 없음: {missing_columns}")
                return {"success": False, "msg": f"필수 컬럼이 없음: {missing_columns}"}
            
            # 필수 데이터가 있는지 확인
            missing_data = df[required_columns].isnull().any(axis=1)
            if missing_data.any():
                self.logger.warning(f"필수 데이터가 누락된 행 수: {missing_data.sum()}")
                for idx in df[missing_data].index:
                    missing_fields = [col for col in required_columns if pd.isnull(df.loc[idx, col])]
                    self.logger.warning(f"행 {idx + 2}의 누락된 필드: {missing_fields}")
                # 필수 데이터가 없는 행 제거
                df = df.dropna(subset=required_columns)
                self.logger.info(f"필수 데이터가 있는 행만 유지: {len(df)}행")
            
            # 환자명과 의사명 정규화
            for col in ['환자 명', '진단 의사명']:
                if col in df.columns:
                    df[col] = df[col].apply(lambda x: self.standardize_value(x, preserve_format=True) if pd.notnull(x) else '')
            
            # 환불 처리: 음수 금액이 있는 행 찾기
            refund_rows = df[df['양'] < 0].copy()
            if not refund_rows.empty:
                self.logger.info(f"환불 데이터 {len(refund_rows)}건 발견")
                
                # 환불 처리할 행 찾기
                for _, refund_row in refund_rows.iterrows():
                    refund_amount = abs(refund_row['양'])
                    refund_date = refund_row['원본_날짜']
                    
                    if pd.isnull(refund_date):
                        self.logger.warning(f"환불 거래의 날짜가 없음: {refund_row['환자 명']} - {refund_amount}원")
                        df = df.drop(refund_row.name)
                        continue
                    
                    # 같은 환자, 같은 의사, 같은 금액의 양수 거래 찾기
                    matching_rows = df[
                        (df['환자 명'] == refund_row['환자 명']) &
                        (df['진단 의사명'] == refund_row['진단 의사명']) &
                        (df['양'] == refund_amount) &
                        (df['원본_날짜'].notna())
                    ].copy()
                    
                    if not matching_rows.empty:
                        try:
                            # 날짜 차이 계산
                            matching_rows['날짜_차이'] = abs(matching_rows['원본_날짜'] - refund_date)
                            
                            # 날짜 차이가 있는 행만 필터링
                            valid_matches = matching_rows[matching_rows['날짜_차이'].notna()]
                            
                            if not valid_matches.empty:
                                # 가장 가까운 날짜의 거래 선택
                                closest_row = valid_matches.loc[valid_matches['날짜_차이'].idxmin()]
                                
                                # 매칭되는 행 제외
                                df = df.drop(closest_row.name)
                                self.logger.info(f"환불 처리: {refund_row['환자 명']} - {refund_amount}원 (날짜 차이: {closest_row['날짜_차이'].days}일)")
                            else:
                                self.logger.warning(f"유효한 날짜 차이가 있는 매칭 거래를 찾을 수 없음: {refund_row['환자 명']} - {refund_amount}원")
                                df = df.drop(refund_row.name)
                        except Exception as e:
                            self.logger.warning(f"환불 매칭 처리 중 오류 발생: {str(e)}")
                            df = df.drop(refund_row.name)
                    else:
                        self.logger.warning(f"환불에 매칭되는 거래를 찾을 수 없음: {refund_row['환자 명']} - {refund_amount}원")
                        df = df.drop(refund_row.name)
            
            # 원본 날짜 컬럼 삭제
            df = df.drop('원본_날짜', axis=1)
            
            # 데이터 처리 전 컬럼 확인
            self.logger.info(f"최종 컬럼 목록: {df.columns.tolist()}")
            self.logger.info(f"첫 번째 행 데이터: {df.iloc[0].to_dict() if not df.empty else '데이터 없음'}")
            
            table = self.find_table("고객관리자동", wb)
            if not table:
                self.logger.error("고객관리자동 테이블을 찾을 수 없음")
                return {"success": False, "msg": "고객관리자동 테이블 없음"}
            
            sheet = None
            for ws in wb.worksheets:
                if table in ws.tables.values():
                    sheet = ws
                    break
            
            if not sheet:
                self.logger.error("고객관리자동 테이블이 있는 시트를 찾을 수 없음")
                return {"success": False, "msg": "고객관리자동 테이블이 있는 시트를 찾을 수 없음"}

            min_col, min_row, max_col, max_row = range_boundaries(table.ref)
            headers = []
            for col in range(min_col, max_col + 1):
                cell_value = sheet.cell(row=min_row, column=col).value
                headers.append(cell_value if cell_value else '')
            
            self.logger.debug(f"엑셀 테이블 헤더: {headers}")
            
            column_indices = {}
            for header in column_mapping.values():
                if header in headers:
                    column_indices[header] = headers.index(header) + min_col
                else:
                    self.logger.warning(f"필수 컬럼을 찾을 수 없음: {header}")

            # 필수 컬럼 확인 및 처리
            required_columns = ['환자 명', '등록날짜', '진단 의사명']
            missing_columns = [col for col in required_columns if col not in column_indices]
            if missing_columns:
                self.logger.warning(f"일부 컬럼을 찾을 수 없음: {', '.join(missing_columns)}")
                self.logger.info("해당 컬럼은 건너뛰고 나머지 데이터를 처리합니다.")
            
            # 기존 데이터 수집 (등록날짜와 환자명 기준)
            existing_records = set()
            for row in range(min_row + 1, max_row + 1):
                name = self.standardize_value(sheet.cell(row=row, column=column_indices['환자 명']).value, preserve_format=True)
                date = self.standardize_date(sheet.cell(row=row, column=column_indices.get('등록날짜', 0)).value) if '등록날짜' in column_indices else None
                if name and date:
                    existing_records.add((name, date))
                    self.logger.debug(f"기존 데이터 수집: {name} - {date}")

            added_count = 0
            skipped_count = 0
            excluded_count = 0
            
            # 제외 키워드가 포함된 행 제거
            for idx, row in df.iterrows():
                if self.should_exclude_row(row):
                    self.logger.info(f"제외 키워드가 포함된 행 제거: {row.get('환자', '')}")
                    df = df.drop(idx)
                    excluded_count += 1
            
            df = df.sort_values('등록날짜') if '등록날짜' in df.columns else df
            
            for idx, row in df.iterrows():
                name = self.standardize_value(row.get('환자 명', ''), preserve_format=True)
                date = self.standardize_date(row.get('등록날짜', '')) if '등록날짜' in df.columns else None
                doctor = self.standardize_value(row.get('진단 의사명', ''), preserve_format=True) if '진단 의사명' in df.columns else None
                
                # 필수 데이터 검증
                missing_fields = []
                if not name:
                    missing_fields.append('환자 명')
                if not date:
                    missing_fields.append('등록날짜')
                if not doctor:
                    missing_fields.append('진단 의사명')
                
                if missing_fields:
                    self.logger.warning(f"필수 데이터 누락 (행 {idx + 2}): {', '.join(missing_fields)}")
                    skipped_count += 1
                    continue
                
                # 등록날짜와 환자명 기준으로 중복 체크
                if (name, date) in existing_records:
                    self.logger.info(f"중복 데이터 건너뛰기: {name} - {date} (등록날짜와 환자명이 일치)")
                    skipped_count += 1
                    continue
                
                max_row += 1
                for header, col in column_indices.items():
                    value = row.get(header, '')
                    sheet.cell(row=max_row, column=col).value = value
                    
                    if max_row > min_row + 1:
                        try:
                            source_cell = sheet.cell(row=min_row + 1, column=col)
                            if source_cell.has_style:
                                sheet.cell(row=max_row, column=col).font = copy(source_cell.font)
                                sheet.cell(row=max_row, column=col).fill = copy(source_cell.fill)
                                sheet.cell(row=max_row, column=col).border = copy(source_cell.border)
                                sheet.cell(row=max_row, column=col).alignment = copy(source_cell.alignment)
                        except Exception as e:
                            self.logger.warning(f"셀 스타일 복사 실패 (행: {max_row}, 열: {col}): {str(e)}")
                
                existing_records.add((name, date))
                added_count += 1
                self.logger.info(f"데이터 추가 완료: {name} - {date}")

            if added_count > 0:
                table.ref = f"{get_column_letter(min_col)}{min_row}:{get_column_letter(max_col)}{max_row}"
            wb.save(main_file)
            
            self.logger.info(f"결제 항목 처리 완료: {added_count}건 추가, {skipped_count}건 중복/오류, {excluded_count}건 제외")
            return {
                "success": True, 
                "msg": f"데이터 {added_count}건 추가, 중복/오류 {skipped_count}건, 제외 {excluded_count}건"
            }
        except Exception as e:
            self.logger.error(f"결제 항목 처리 중 오류 발생: {str(e)}", exc_info=True)
            return {"success": False, "msg": str(e)}

    def run_patient_update(self, main_file):
        try:
            self.logger.info("환자 정보 업데이트 시작")
            
            wb = load_workbook(main_file)
            self.logger.info(f"메인 파일 로드 완료: {main_file}")
            
            # 회원자동 테이블 찾기
            patients_table = self.find_table("회원자동", wb)
            if not patients_table:
                self.logger.error("회원자동 테이블을 찾을 수 없음")
                return {"success": False, "msg": "회원자동 테이블 없음"}
            
            # 고객관리자동 테이블 찾기
            customer_table = self.find_table("고객관리자동", wb)
            if not customer_table:
                self.logger.error("고객관리자동 테이블을 찾을 수 없음")
                return {"success": False, "msg": "고객관리자동 테이블 없음"}
            
            # 회원자동 시트와 고객관리자동 시트 찾기
            patients_sheet = None
            customer_sheet = None
            for sheet in wb.worksheets:
                if patients_table in sheet.tables.values():
                    patients_sheet = sheet
                    self.logger.info(f"회원자동 시트 찾음: {sheet.title}")
                if customer_table in sheet.tables.values():
                    customer_sheet = sheet
                    self.logger.info(f"고객관리자동 시트 찾음: {sheet.title}")
            
            if not patients_sheet or not customer_sheet:
                self.logger.error("필요한 시트를 찾을 수 없음")
                return {"success": False, "msg": "필요한 시트를 찾을 수 없음"}
            
            # 회원자동 테이블 범위
            p_min_col, p_min_row, p_max_col, p_max_row = range_boundaries(patients_table.ref)
            self.logger.info(f"회원자동 테이블 범위: {patients_table.ref}")
            
            # 고객관리자동 테이블 범위
            c_min_col, c_min_row, c_max_col, c_max_row = range_boundaries(customer_table.ref)
            self.logger.info(f"고객관리자동 테이블 범위: {customer_table.ref}")
            
            # 헤더 매핑
            patients_headers = {}
            customer_headers = {}
            
            # 회원자동 헤더
            for col in range(p_min_col, p_max_col + 1):
                header = patients_sheet.cell(row=p_min_row, column=col).value
                if header:
                    patients_headers[header] = col
                    self.logger.debug(f"회원자동 헤더: {header} -> 열 {col}")
            
            # 고객관리자동 헤더
            for col in range(c_min_col, c_max_col + 1):
                header = customer_sheet.cell(row=c_min_row, column=col).value
                if header:
                    customer_headers[header] = col
                    self.logger.debug(f"고객관리자동 헤더: {header} -> 열 {col}")
            
            self.logger.info(f"회원자동 헤더 목록: {list(patients_headers.keys())}")
            self.logger.info(f"고객관리자동 헤더 목록: {list(customer_headers.keys())}")
            
            # 환자 데이터 수집
            patients_data = {}
            for row in range(p_min_row + 1, p_max_row + 1):
                name = patients_sheet.cell(row=row, column=patients_headers.get("이름")).value
                birth_date = patients_sheet.cell(row=row, column=patients_headers.get("생년월일")).value
                age_range = patients_sheet.cell(row=row, column=patients_headers.get("연령대")).value
                age = patients_sheet.cell(row=row, column=patients_headers.get("나이")).value
                gender = patients_sheet.cell(row=row, column=patients_headers.get("성별")).value
                state = patients_sheet.cell(row=row, column=patients_headers.get("주")).value
                
                if name:
                    # 생년 처리 (이전 방식 + 영문 등 다양한 날짜 포맷 지원)
                    birth_year = ""
                    if birth_date and isinstance(birth_date, str):
                        if "년" in birth_date:
                            birth_year = birth_date.split("년")[0]
                        elif "월" in birth_date and "," in birth_date:
                            birth_year = birth_date.split(",")[1].strip()
                        else:
                            # 영문 등 다양한 날짜 포맷 지원
                            try:
                                dt = pd.to_datetime(birth_date, errors='coerce')
                                if pd.notnull(dt):
                                    birth_year = str(dt.year)
                            except Exception:
                                birth_year = ""
                    patients_data[name] = {
                        "생년": birth_year,
                        "연령대": age_range if age_range else "",
                        "나이": age if age else "",
                        "성별": gender if gender else "",
                        "주": state if state else ""
                    }
            
            self.logger.info(f"수집된 환자 데이터 수: {len(patients_data)}")
            
            # 고객관리자동 테이블 업데이트
            updated_count = 0
            empty_rows = []  # 공란인 행 번호 저장
            
            for row in range(c_min_row + 1, c_max_row + 1):
                name = customer_sheet.cell(row=row, column=customer_headers.get("환자 명")).value
                if name and name in patients_data:
                    data = patients_data[name]
                    
                    # 생년 업데이트
                    if "생년" in customer_headers:
                        cell = customer_sheet.cell(row=row, column=customer_headers["생년"])
                        cell.value = data["생년"]
                        cell.number_format = '@'
                    
                    # 연령대 업데이트
                    if "연령대" in customer_headers:
                        cell = customer_sheet.cell(row=row, column=customer_headers["연령대"])
                        cell.value = data["연령대"]
                        cell.number_format = '@'
                    
                    # 나이 업데이트
                    if "나이" in customer_headers:
                        cell = customer_sheet.cell(row=row, column=customer_headers["나이"])
                        cell.value = data["나이"]
                        cell.number_format = '@'
                    
                    # 성별 업데이트 (male/female -> 남/여)
                    if "성별" in customer_headers:
                        cell = customer_sheet.cell(row=row, column=customer_headers["성별"])
                        gender_val = data["성별"].strip().lower() if data["성별"] else ""
                        if gender_val == "male":
                            cell.value = "남"
                        elif gender_val == "female":
                            cell.value = "여"
                        else:
                            cell.value = data["성별"]
                        cell.number_format = '@'
                    
                    # 주 업데이트
                    if "주" in customer_headers:
                        cell = customer_sheet.cell(row=row, column=customer_headers["주"])
                        cell.value = data["주"]
                        cell.number_format = '@'
                    
                    updated_count += 1
                else:
                    # 행의 모든 셀이 비어있는지 확인
                    is_empty = True
                    for col in range(c_min_col, c_max_col + 1):
                        if customer_sheet.cell(row=row, column=col).value:
                            is_empty = False
                            break
                    if is_empty:
                        empty_rows.append(row)
            
            # 다른 행이 없는 경우에만 첫 번째 행 보존
            if len(empty_rows) == c_max_row - c_min_row:
                empty_rows.remove(c_min_row + 1)  # 첫 번째 행은 보존
            
            # 빈 행 삭제 (역순으로 삭제하여 인덱스 변화 방지)
            for row in sorted(empty_rows, reverse=True):
                customer_sheet.delete_rows(row)
                c_max_row -= 1

            # 테이블 범위 업데이트
            if updated_count > 0:
                customer_table.ref = f"{get_column_letter(c_min_col)}{c_min_row}:{get_column_letter(c_max_col)}{c_max_row}"
            
            wb.save(main_file)
            self.logger.info(f"환자 정보 업데이트 완료: {updated_count}건 업데이트, {len(empty_rows)}건 공란 행 삭제")
            
            return {"success": True, "msg": f"{updated_count}건의 환자 정보 업데이트 완료, {len(empty_rows)}건의 공란 행 삭제"}
            
        except Exception as e:
            self.logger.error(f"환자 정보 업데이트 중 오류 발생: {str(e)}", exc_info=True)
            return {"success": False, "msg": str(e)}

    def run_table_update(self, main_file, patients_file=None, payment_file=None, update_patient_info=True):
        try:
            self.logger.info("테이블 업데이트 작업 시작")
            
            # 메인 파일만 체크
            if not os.path.exists(main_file):
                self.logger.error(f"메인 파일이 존재하지 않습니다: {main_file}")
                return {"success": False, "msg": "메인 파일이 존재하지 않습니다"}
            
            backup_dir = os.path.join(os.path.dirname(main_file), "BACK UP")
            os.makedirs(backup_dir, exist_ok=True)
            backup_file = os.path.join(backup_dir, f"BACKUP_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{os.path.basename(main_file)}")
            shutil.copy2(main_file, backup_file)
            self.logger.info(f"파일 백업 완료: {backup_file}")
            
            result = {}
            
            # 환자 파일 처리
            if patients_file and os.path.exists(patients_file):
                self.logger.info("환자 파일 처리 시작")
                result['patients'] = self.process_patients_file(main_file, patients_file)
                if not result['patients']['success']:
                    self.logger.error("환자 파일 처리 실패")
                    return result
            else:
                self.logger.info("환자 파일이 없어 처리하지 않습니다")
                result['patients'] = {"success": True, "msg": "환자 파일 없음"}
            
            # 결제 파일 처리
            if payment_file and os.path.exists(payment_file):
                self.logger.info("결제 파일 처리 시작")
                result['payments'] = self.process_PaymentItems_items(main_file, payment_file)
                if not result['payments']['success']:
                    self.logger.error("결제 파일 처리 실패")
                    return result
            else:
                self.logger.info("결제 파일이 없어 처리하지 않습니다")
                result['payments'] = {"success": True, "msg": "결제 파일 없음"}
            
            # 환자 정보 업데이트 여부 확인
            if update_patient_info:
                result['update'] = self.run_patient_update(main_file)
                if not result['update']['success']:
                    self.logger.error("환자 정보 업데이트 실패")
                    return result
            else:
                self.logger.info("환자 정보 업데이트를 건너뜁니다")
                result['update'] = {"success": True, "msg": "환자 정보 업데이트 건너뜀"}
            
            self.logger.info("테이블 업데이트 작업 완료")
            return {"success": True, "msg": "표 업데이트 전체 완료", "detail": result}
        except Exception as e:
            self.logger.error(f"테이블 업데이트 중 오류 발생: {str(e)}", exc_info=True)
            return {"success": False, "msg": str(e)}

    def calculate_age_from_birthdate(self, birthdate_str):
        if not birthdate_str or pd.isna(birthdate_str):
            return None
        try:
            # 1. 한글 "월"과 ","가 있는 형식 처리
            if "월" in str(birthdate_str) and "," in str(birthdate_str):
                month = int(str(birthdate_str).split("월")[0])
                day = int(str(birthdate_str).split(",")[0].split("월")[1].strip())
                year = int(str(birthdate_str).split(",")[1].strip())
                birth_date = datetime(year, month, day)
            else:
                # 2. pandas로 다양한 날짜 포맷 자동 파싱 (영문, 숫자 등)
                dt = pd.to_datetime(birthdate_str, errors='coerce')
                if pd.isnull(dt):
                    return None
                birth_date = dt.to_pydatetime()
            today = datetime.now()
            age = today.year - birth_date.year
            if (today.month, today.day) < (birth_date.month, birth_date.day):
                age -= 1
            return age
        except Exception as e:
            self.logger.warning(f"나이 계산 실패: {birthdate_str} -> {str(e)}")
            return None

    def get_age_range(self, age):
        if age is None:
            self.logger.warning("나이가 None이어서 연령대를 계산할 수 없음")
            return None
        try:
            if age < 20:
                return "10s"
            elif age < 30:
                return "20s"
            elif age < 40:
                return "30s"
            elif age < 50:
                return "40s"
            elif age < 60:
                return "50s"
            elif age < 70:
                return "60s"
            else:
                return "70s+"
        except Exception as e:
            self.logger.warning(f"연령대 계산 중 오류 발생: {age} -> {str(e)}")
            return None

    def run_chart_update(self, main_file, selected_year=None, selected_month=None):
        """도표 업데이트 기능 실행"""
        self.logger.info("도표 업데이트 시작")
        self.logger.info(f"메인 파일: {main_file}")
        try:
            # 메인 파일 존재 확인
            if not os.path.exists(main_file):
                self.logger.error(f"메인 파일이 존재하지 않음: {main_file}")
                return {"success": False, "msg": "메인 파일을 찾을 수 없습니다."}
            
            # 메인 파일 로드
            self.logger.info("메인 파일 로드 시작")
            wb = load_workbook(main_file)
            self.logger.info("메인 파일 로드 완료")
            
            # 선택된 연도와 월이 없으면 현재 날짜 사용
            if selected_year is None or selected_month is None:
                now = datetime.now()
                selected_year = now.year
                selected_month = now.month
            
            month_str = str(selected_month)
            
            # 디버그 로그 추가
            self.logger.info(f"\n=== 선택된 날짜 정보 ===")
            self.logger.info(f"선택된 연도: {selected_year}")
            self.logger.info(f"선택된 월: {selected_month}")
            self.logger.info(f"월 문자열: {month_str}")
            self.logger.info(f"=== 선택된 날짜 정보 끝 ===\n")
            
            # 새로운 시트 이름
            new_patients_sheet_name = f"{month_str}월_회원"
            new_payment_sheet_name = f"{month_str}월_진료"
            self.logger.info(f"새로운 시트 이름: {new_patients_sheet_name}, {new_payment_sheet_name}")
            # 기존 시트 찾기
            existing_patients_sheet = None
            existing_payment_sheet = None
            old_patients_name = None
            old_payment_name = None
            for sheet_name in wb.sheetnames:
                if sheet_name.endswith("_회원"):
                    existing_patients_sheet = wb[sheet_name]
                    old_patients_name = sheet_name
                    self.logger.info(f"기존 회원 시트 발견: {sheet_name}")
                elif sheet_name.endswith("_진료"):
                    existing_payment_sheet = wb[sheet_name]
                    old_payment_name = sheet_name
                    self.logger.info(f"기존 진료 시트 발견: {sheet_name}")
            if not existing_patients_sheet or not existing_payment_sheet:
                self.logger.error("필요한 시트를 찾을 수 없음")
                return {"success": False, "msg": "필요한 시트를 찾을 수 없습니다."}
            # 시트 이름 변경
            self.logger.info(f"시트 이름 변경 시도: {old_patients_name} → {new_patients_sheet_name}")
            if existing_patients_sheet.title != new_patients_sheet_name:
                existing_patients_sheet.title = new_patients_sheet_name
                self.logger.info(f"회원 시트 이름 변경 완료: {old_patients_name} → {existing_patients_sheet.title}")
            else:
                self.logger.info(f"회원 시트 이름이 이미 {new_patients_sheet_name}임")
            self.logger.info(f"시트 이름 변경 시도: {old_payment_name} → {new_payment_sheet_name}")
            if existing_payment_sheet.title != new_payment_sheet_name:
                existing_payment_sheet.title = new_payment_sheet_name
                self.logger.info(f"진료 시트 이름 변경 완료: {old_payment_name} → {existing_payment_sheet.title}")
            else:
                self.logger.info(f"진료 시트 이름이 이미 {new_payment_sheet_name}임")
            # 시트 이름 변경 후 저장
            wb.save(main_file)
            self.logger.info(f"시트 이름 변경 후 저장 완료: {main_file}")

            # ★★★ 반드시 최근회원/최근진료 테이블 복사(업데이트)부터 실행 ★★★
            # 테이블 찾기
            patients_table = self.find_table("최근회원", existing_patients_sheet)
            payment_table = self.find_table("최근진료", existing_payment_sheet)
            if not patients_table:
                self.logger.error("최근회원 테이블을 찾을 수 없음")
                return {"success": False, "msg": "최근회원 테이블을 찾을 수 없습니다."}
            if not payment_table:
                self.logger.error("최근진료 테이블을 찾을 수 없음")
                return {"success": False, "msg": "최근진료 테이블을 찾을 수 없습니다."}
            # 회원자동, 고객관리자동 테이블 찾기
            auto_patients_table = self.find_table("회원자동", wb)
            auto_customers_table = self.find_table("고객관리자동", wb)
            if not auto_patients_table or not auto_customers_table:
                self.logger.error("회원자동/고객관리자동 테이블을 찾을 수 없음")
                return {"success": False, "msg": "회원자동/고객관리자동 테이블을 찾을 수 없습니다."}
            # 시트 찾기
            auto_patients_sheet = None
            auto_customers_sheet = None
            for sheet in wb.worksheets:
                if auto_patients_table in sheet.tables.values():
                    auto_patients_sheet = sheet
                if auto_customers_table in sheet.tables.values():
                    auto_customers_sheet = sheet
            # 테이블 범위
            p_min_col, p_min_row, p_max_col, p_max_row = range_boundaries(patients_table.ref)
            py_min_col, py_min_row, py_max_col, py_max_row = range_boundaries(payment_table.ref)
            ap_min_col, ap_min_row, ap_max_col, ap_max_row = range_boundaries(auto_patients_table.ref)
            ac_min_col, ac_min_row, ac_max_col, ac_max_row = range_boundaries(auto_customers_table.ref)
            # 헤더 추출
            patients_headers = [existing_patients_sheet.cell(row=p_min_row, column=col).value for col in range(p_min_col, p_max_col+1)]
            auto_patients_headers = [auto_patients_sheet.cell(row=ap_min_row, column=col).value for col in range(ap_min_col, ap_max_col+1)]
            payment_headers = [existing_payment_sheet.cell(row=py_min_row, column=col).value for col in range(py_min_col, py_max_col+1)]
            auto_customers_headers = [auto_customers_sheet.cell(row=ac_min_row, column=col).value for col in range(ac_min_col, ac_max_col+1)]
            # 최근달 데이터만 추출 (등록 날짜/등록날짜 기준)
            # 회원자동 → 최근회원
            recent_rows = []
            for row in range(ap_min_row+1, ap_max_row+1):
                date_val = auto_patients_sheet.cell(row=row, column=auto_patients_headers.index("등록 날짜")+ap_min_col).value
                if date_val:
                    try:
                        if "년" in str(date_val) and "월" in str(date_val):
                            y = int(date_val.split("년")[0])
                            m = int(date_val.split("년")[1].split("월")[0].strip())
                            if y == selected_year and m == selected_month:
                                recent_rows.append(row)
                    except:
                        continue
            # 최근회원 테이블 업데이트
            # 테이블 범위 유지
            p_min_col, p_min_row, p_max_col, p_max_row = range_boundaries(patients_table.ref)
            # 헤더 아래 첫 번째 행부터 데이터 입력
            current_row = p_min_row + 1
            
            # 기존 데이터 삭제 (헤더 제외)
            for row in range(p_min_row+1, p_max_row+1):
                for col in range(p_min_col, p_max_col+1):
                    cell = existing_patients_sheet.cell(row=row, column=col)
                    cell.value = None
                    # 셀 서식 초기화
                    cell.font = None
                    cell.fill = PatternFill(fill_type=None)
                    cell.border = None
                    cell.alignment = None

            # 데이터 입력
            for i, src_row in enumerate(recent_rows):
                for j, header in enumerate(patients_headers):
                    if header in auto_patients_headers:
                        src_col = auto_patients_headers.index(header) + ap_min_col
                        dst_col = p_min_col + j
                        val = auto_patients_sheet.cell(row=src_row, column=src_col).value
                        existing_patients_sheet.cell(row=current_row+i, column=dst_col).value = val
            
            # 테이블 범위 업데이트
            last_row = current_row + len(recent_rows) - 1
            if last_row < p_min_row + 1:  # 데이터가 없는 경우
                last_row = p_min_row + 1  # 최소 1행 유지
            patients_table.ref = f"{get_column_letter(p_min_col)}{p_min_row}:{get_column_letter(p_max_col)}{last_row}"
            # 테이블 속성 보존
            patients_table.autoFilter = AutoFilter(ref=f"{get_column_letter(p_min_col)}{p_min_row}:{get_column_letter(p_max_col)}{last_row}")
            patients_table.displayName = "최근회원"
            patients_table.name = "최근회원"

            # 최근진료 테이블 업데이트
            # 테이블 범위 유지
            py_min_col, py_min_row, py_max_col, py_max_row = range_boundaries(payment_table.ref)
            # 헤더 아래 첫 번째 행부터 데이터 입력
            current_row = py_min_row + 1
            
            # 기존 데이터 삭제 (헤더 제외)
            for row in range(py_min_row+1, py_max_row+1):
                for col in range(py_min_col, py_max_col+1):
                    cell = existing_payment_sheet.cell(row=row, column=col)
                    cell.value = None
                    # 셀 서식 초기화
                    cell.font = None
                    cell.fill = PatternFill(fill_type=None)
                    cell.border = None
                    cell.alignment = None

            # 고객관리자동 테이블에서 선택한 연도와 월의 데이터만 추출
            recent_payment_rows = []
            for row in range(ac_min_row+1, ac_max_row+1):
                date_val = auto_customers_sheet.cell(row=row, column=auto_customers_headers.index("등록날짜")+ac_min_col).value
                if date_val:
                    try:
                        if "년" in str(date_val) and "월" in str(date_val):
                            y = int(str(date_val).split("년")[0])
                            m = int(str(date_val).split("년")[1].split("월")[0].strip())
                            if y == selected_year and m == selected_month:
                                recent_payment_rows.append(row)
                    except:
                        continue
            
            # 데이터 입력
            for i, src_row in enumerate(recent_payment_rows):
                for j, header in enumerate(payment_headers):
                    if header in auto_customers_headers:
                        src_col = auto_customers_headers.index(header) + ac_min_col
                        dst_col = py_min_col + j
                        val = auto_customers_sheet.cell(row=src_row, column=src_col).value
                        existing_payment_sheet.cell(row=current_row+i, column=dst_col).value = val
            
            # 테이블 범위 업데이트
            last_row = current_row + len(recent_payment_rows) - 1
            if last_row < py_min_row + 1:  # 데이터가 없는 경우
                last_row = py_min_row + 1  # 최소 1행 유지
            payment_table.ref = f"{get_column_letter(py_min_col)}{py_min_row}:{get_column_letter(py_max_col)}{last_row}"
            # 테이블 속성 보존
            payment_table.autoFilter = AutoFilter(ref=f"{get_column_letter(py_min_col)}{py_min_row}:{get_column_letter(py_max_col)}{last_row}")
            payment_table.displayName = "최근진료"
            payment_table.name = "최근진료"

            # ★★★ 여기서부터 월별회원 테이블 자동 업데이트 및 후처리 진행 ★★★
            try:
                summary_sheet = None
                summary_table = None
                for sheet in wb.worksheets:
                    if sheet.title == "월별회원가입지표":
                        summary_sheet = sheet
                        break
                if summary_sheet is None:
                    self.logger.error("월별회원가입지표 시트를 찾을 수 없음")
                    return {"success": False, "msg": "월별회원가입지표 시트를 찾을 수 없습니다."}
                summary_table = self.find_table("월별회원", summary_sheet)
                if summary_table is None:
                    self.logger.error("월별회원 테이블을 찾을 수 없음")
                    return {"success": False, "msg": "월별회원 테이블을 찾을 수 없습니다."}
                
                # 회원자동 테이블에서 월별 회원 수 계산
                ap_min_col, ap_min_row, ap_max_col, ap_max_row = range_boundaries(auto_patients_table.ref)
                monthly_counts = {}  # {year.month: count}
                
                for row in range(ap_min_row+1, ap_max_row+1):
                    date_val = auto_patients_sheet.cell(row=row, column=auto_patients_headers.index("등록 날짜")+ap_min_col).value
                    if date_val:
                        try:
                            if "년" in str(date_val) and "월" in str(date_val):
                                y = int(str(date_val).split("년")[0])
                                m = int(str(date_val).split("년")[1].split("월")[0].strip())
                                period_key = f"{y}.{m:02d}"
                                monthly_counts[period_key] = monthly_counts.get(period_key, 0) + 1
                        except:
                            continue
                
                self.logger.info(f"월별 회원 수 계산 완료: {monthly_counts}")
                
                # 테이블 범위 가져오기
                s_min_col, s_min_row, s_max_col, s_max_row = range_boundaries(summary_table.ref)
                
                # 기존 데이터 삭제 (헤더 제외)
                for row in range(s_min_row+1, s_max_row+1):
                    for col in range(s_min_col, s_max_col+1):
                        cell = summary_sheet.cell(row=row, column=col)
                        cell.value = None
                        cell.font = None
                        cell.fill = PatternFill(fill_type=None)
                        cell.border = None
                        cell.alignment = None

                # 데이터 입력
                current_row = s_min_row + 1
                total_cumulative = 0
                
                # 날짜를 연속된 순서로 정렬
                sorted_periods = sorted(monthly_counts.keys())
                if len(sorted_periods) > 1:
                    # 첫 번째 날짜와 선택한 날짜 사이의 모든 월을 생성
                    start_year, start_month = map(int, sorted_periods[0].split('.'))
                    
                    # 연속된 날짜 목록 생성 (선택한 연도와 월까지만)
                    continuous_periods = []
                    current_year, current_month = start_year, start_month
                    while (current_year < selected_year) or (current_year == selected_year and current_month <= selected_month):
                        period_key = f"{current_year}.{current_month:02d}"
                        continuous_periods.append(period_key)
                        
                        current_month += 1
                        if current_month > 12:
                            current_month = 1
                            current_year += 1
                    
                    # 연속된 날짜에 대해 데이터 입력
                    for period in continuous_periods:
                        count = monthly_counts.get(period, 0)  # 해당 월의 데이터가 없으면 0
                        total_cumulative += count
                        
                        summary_sheet.cell(row=current_row, column=s_min_col).value = period
                        summary_sheet.cell(row=current_row, column=s_min_col+1).value = count
                        summary_sheet.cell(row=current_row, column=s_min_col+2).value = total_cumulative
                        current_row += 1
                else:
                    # 데이터가 하나뿐인 경우
                    for period in sorted_periods:
                        year, month = map(int, period.split('.'))
                        # 선택한 연도와 월 이전의 데이터만 포함
                        if (year < selected_year) or (year == selected_year and month <= selected_month):
                            count = monthly_counts[period]
                            total_cumulative += count
                            
                            summary_sheet.cell(row=current_row, column=s_min_col).value = period
                            summary_sheet.cell(row=current_row, column=s_min_col+1).value = count
                            summary_sheet.cell(row=current_row, column=s_min_col+2).value = total_cumulative
                            current_row += 1
                
                # 테이블 범위 업데이트
                last_row = current_row - 1
                if last_row < s_min_row + 1:  # 데이터가 없는 경우
                    last_row = s_min_row + 1  # 최소 1행 유지
                summary_table.ref = f"{get_column_letter(s_min_col)}{s_min_row}:{get_column_letter(s_max_col)}{last_row}"
                
                # 테이블 속성 보존
                summary_table.autoFilter = AutoFilter(ref=f"{get_column_letter(s_min_col)}{s_min_row}:{get_column_letter(s_max_col)}{last_row}")
                summary_table.displayName = "월별회원"
                summary_table.name = "월별회원"
                
                # --- 차트 관련 코드 전체 삭제 (수동으로 관리할 것이므로) ---
                # 기존 차트의 디자인 저장, 삭제, 새 차트 생성, 속성 복사, summary_sheet.add_chart 등
                # chart = LineChart() ... summary_sheet.add_chart(chart, ...) 등 모두 제거
                # 데이터 집계, summary_table.ref, summary_table.autoFilter 등은 그대로 유지
            except Exception as e:
                self.logger.error(f"월별회원 테이블 업데이트 중 오류 발생: {str(e)}")
                return {"success": False, "msg": f"월별회원 테이블 업데이트 중 오류 발생: {str(e)}"}

            # 수식 업데이트 (기존 코드)
            updated_formulas = 0
            for sheet in wb.worksheets:
                for row in sheet.iter_rows():
                    for cell in row:
                        if cell.value and isinstance(cell.value, str) and cell.value.startswith('='):
                            formula = cell.value
                            if old_patients_name and old_patients_name in formula:
                                formula = formula.replace(old_patients_name, new_patients_sheet_name)
                                updated_formulas += 1
                            if old_payment_name and old_payment_name in formula:
                                formula = formula.replace(old_payment_name, new_payment_sheet_name)
                                updated_formulas += 1
                            cell.value = formula
            self.logger.info(f"수식 업데이트 완료: {updated_formulas}개의 수식이 업데이트됨")
            wb.save(main_file)

            # --- 여기서부터 30일간회원가입수 시트의 월별가입 테이블 업데이트 추가 ---
            try:
                # 1. 30일간회원가입수 시트와 월별가입 테이블 찾기
                month_join_sheet = None
                month_join_table = None
                for sheet in wb.worksheets:
                    if sheet.title == "30일간회원가입수":
                        month_join_sheet = sheet
                        break
                if month_join_sheet is None:
                    self.logger.error("30일간회원가입수 시트를 찾을 수 없음")
                    # 이 기능만 실패해도 전체 실패로 만들지 않고 넘어감
                else:
                    # 시트 내의 모든 텍스트를 최근 달로 업데이트
                    for row in month_join_sheet.iter_rows():
                        for cell in row:
                            if cell.value and isinstance(cell.value, str):
                                # "X월 일별 회원 가입자 수 추이" 패턴 찾기
                                if "월 일별 회원 가입자 수 추이" in cell.value:
                                    old_value = cell.value
                                    new_value = f"{selected_month}월 일별 회원 가입자 수 추이"
                                    
                                    # 이전 값과 새로운 값이 다른 경우에만 업데이트
                                    if old_value != new_value:
                                        cell.value = new_value
                                        self.logger.info(f"\n=== 텍스트 업데이트 상세 ===")
                                        self.logger.info(f"셀 위치: {cell.coordinate}")
                                        self.logger.info(f"이전 값: {old_value}")
                                        self.logger.info(f"새로운 값: {new_value}")
                                        self.logger.info(f"현재 달: {selected_month}월")
                                        self.logger.info(f"=== 텍스트 업데이트 끝 ===\n")
                                    else:
                                        self.logger.info(f"\n=== 텍스트 업데이트 불필요 ===")
                                        self.logger.info(f"셀 위치: {cell.coordinate}")
                                        self.logger.info(f"현재 값: {old_value}")
                                        self.logger.info(f"현재 달: {selected_month}월")
                                        self.logger.info(f"이미 올바른 달로 설정되어 있음")
                                        self.logger.info(f"=== 텍스트 업데이트 불필요 끝 ===\n")

                    month_join_table = self.find_table("월별가입", month_join_sheet)
                    if month_join_table is None:
                        self.logger.error("월별가입 테이블을 찾을 수 없음")
                    else:
                        # 기존 데이터 삭제 (헤더 제외, 최소 1개 공란 행 남김)
                        mj_min_col, mj_min_row, mj_max_col, mj_max_row = range_boundaries(month_join_table.ref)
                        data_row_start = mj_min_row + 1
                        # 공란 행 확보 (최소 1행)
                        if mj_max_row <= mj_min_row + 1:
                            mj_max_row = mj_min_row + 1
                        # 헤더 아래 모든 행을 공란으로 초기화
                        for row in range(data_row_start, mj_max_row + 1):
                            for col in range(mj_min_col, mj_max_col + 1):
                                cell = month_join_sheet.cell(row=row, column=col)
                                cell.value = None
                                # 셀 서식 초기화
                                cell.font = None
                                cell.fill = PatternFill(fill_type=None)
                                cell.border = None
                                cell.alignment = None

                        # 회원자동 테이블에서 이번 달 데이터만 일자별로 집계
                        date_counter = Counter()
                        for row in range(ap_min_row+1, ap_max_row+1):
                            date_val = auto_patients_sheet.cell(row=row, column=auto_patients_headers.index("등록 날짜")+ap_min_col).value
                            if date_val:
                                try:
                                    if isinstance(date_val, str) and "년" in date_val and "월" in date_val and "일" in date_val:
                                        y = int(date_val.split("년")[0])
                                        m = int(date_val.split("년")[1].split("월")[0].strip())
                                        d = int(date_val.split("월")[1].split("일")[0].strip())
                                        if y == selected_year and m == selected_month:
                                            date_str = f"{y}-{m:02d}-{d:02d}"
                                            date_counter[date_str] += 1
                                except Exception as e:
                                    self.logger.warning(f"날짜 파싱 실패: {date_val} -> {str(e)}")
                                    continue
                        
                        # 일자 오름차순 정렬
                        sorted_dates = sorted(date_counter.items())
                        self.logger.info(f"이번 달 일별 회원 가입 수: {sorted_dates}")
                        
                        # 데이터 입력 (공란 행 포함, 데이터가 있으면 덮어씀)
                        for i, (date_str, cnt) in enumerate(sorted_dates):
                            month_join_sheet.cell(row=data_row_start + i, column=mj_min_col).value = date_str
                            month_join_sheet.cell(row=data_row_start + i, column=mj_min_col + 1).value = cnt
                        
                        # 데이터가 없으면 공란 행만 남김
                        total_rows = max(len(sorted_dates), 1)
                        new_last_row = data_row_start + total_rows - 1
                        month_join_table.ref = f"{get_column_letter(mj_min_col)}{mj_min_row}:{get_column_letter(mj_max_col)}{new_last_row}"
                        # 테이블 속성 보존
                        month_join_table.autoFilter = AutoFilter(ref=f"{get_column_letter(mj_min_col)}{mj_min_row}:{get_column_letter(mj_max_col)}{new_last_row}")
                        month_join_table.displayName = "월별가입"
                        month_join_table.name = "월별가입"
                        wb.save(main_file)
                        self.logger.info(f"30일간회원가입수 시트 업데이트 완료: {len(sorted_dates)}일의 데이터 입력")
            except Exception as e:
                self.logger.error(f"30일간회원가입수 월별가입 테이블 자동 업데이트 중 오류: {str(e)}")

            # --- 여기서부터 월별진료지표 시트의 월별진료 테이블 업데이트 추가 ---
            try:
                # 1. 월별진료지표 시트와 월별진료 테이블 찾기
                treatment_sheet = None
                treatment_table = None
                for sheet in wb.worksheets:
                    if sheet.title == "월별진료지표":
                        treatment_sheet = sheet
                        break
                if treatment_sheet is None:
                    self.logger.error("월별진료지표 시트를 찾을 수 없음")
                    # 이 기능만 실패해도 전체 실패로 만들지 않고 넘어감
                else:
                    treatment_table = self.find_table("월별진료", treatment_sheet)
                    if treatment_table is None:
                        self.logger.error("월별진료 테이블을 찾을 수 없음")
                    else:
                        # 고객관리자동 테이블에서 월별 진료 수 계산
                        ac_min_col, ac_min_row, ac_max_col, ac_max_row = range_boundaries(auto_customers_table.ref)
                        monthly_treatment_counts = {}  # {year.month: count}
                        
                        for row in range(ac_min_row+1, ac_max_row+1):
                            date_val = auto_customers_sheet.cell(row=row, column=auto_customers_headers.index("등록날짜")+ac_min_col).value
                            if date_val:
                                try:
                                    if "년" in str(date_val) and "월" in str(date_val):
                                        y = int(str(date_val).split("년")[0])
                                        m = int(str(date_val).split("년")[1].split("월")[0].strip())
                                        period_key = f"{y}.{m:02d}"
                                        monthly_treatment_counts[period_key] = monthly_treatment_counts.get(period_key, 0) + 1
                                except:
                                    continue
                        
                        self.logger.info(f"월별 진료 수 계산 완료: {monthly_treatment_counts}")
                        
                        # 테이블 범위 가져오기
                        t_min_col, t_min_row, t_max_col, t_max_row = range_boundaries(treatment_table.ref)
                        
                        # 기존 데이터 삭제 (헤더 제외)
                        for row in range(t_min_row+1, t_max_row+1):
                            for col in range(t_min_col, t_max_col+1):
                                cell = treatment_sheet.cell(row=row, column=col)
                                cell.value = None
                                cell.font = None
                                cell.fill = PatternFill(fill_type=None)
                                cell.border = None
                                cell.alignment = None

                        # 데이터 입력
                        current_row = t_min_row + 1
                        total_cumulative = 0
                        
                        # 날짜를 연속된 순서로 정렬
                        sorted_periods = sorted(monthly_treatment_counts.keys())
                        if len(sorted_periods) > 1:
                            # 첫 번째 날짜와 선택한 날짜 사이의 모든 월을 생성
                            start_year, start_month = map(int, sorted_periods[0].split('.'))
                            
                            # 연속된 날짜 목록 생성 (선택한 연도와 월까지만)
                            continuous_periods = []
                            current_year, current_month = start_year, start_month
                            while (current_year < selected_year) or (current_year == selected_year and current_month <= selected_month):
                                period_key = f"{current_year}.{current_month:02d}"
                                continuous_periods.append(period_key)
                                
                                current_month += 1
                                if current_month > 12:
                                    current_month = 1
                                    current_year += 1
                            
                            # 연속된 날짜에 대해 데이터 입력
                            for period in continuous_periods:
                                count = monthly_treatment_counts.get(period, 0)  # 해당 월의 데이터가 없으면 0
                                total_cumulative += count
                                
                                treatment_sheet.cell(row=current_row, column=t_min_col).value = period
                                treatment_sheet.cell(row=current_row, column=t_min_col+1).value = count
                                treatment_sheet.cell(row=current_row, column=t_min_col+2).value = total_cumulative
                                current_row += 1
                        else:
                            # 데이터가 하나뿐인 경우
                            for period in sorted_periods:
                                year, month = map(int, period.split('.'))
                                # 선택한 연도와 월 이전의 데이터만 포함
                                if (year < selected_year) or (year == selected_year and month <= selected_month):
                                    count = monthly_treatment_counts[period]
                                    total_cumulative += count
                                    
                                    treatment_sheet.cell(row=current_row, column=t_min_col).value = period
                                    treatment_sheet.cell(row=current_row, column=t_min_col+1).value = count
                                    treatment_sheet.cell(row=current_row, column=t_min_col+2).value = total_cumulative
                                    current_row += 1
                        
                        # 테이블 범위 업데이트
                        last_row = current_row - 1
                        if last_row < t_min_row + 1:  # 데이터가 없는 경우
                            last_row = t_min_row + 1  # 최소 1행 유지
                        treatment_table.ref = f"{get_column_letter(t_min_col)}{t_min_row}:{get_column_letter(t_max_col)}{last_row}"
                        
                        # 테이블 속성 보존
                        treatment_table.autoFilter = AutoFilter(ref=f"{get_column_letter(t_min_col)}{t_min_row}:{get_column_letter(t_max_col)}{last_row}")
                        treatment_table.displayName = "월별진료"
                        treatment_table.name = "월별진료"
                        
                        wb.save(main_file)
                        self.logger.info(f"월별진료지표 시트 업데이트 완료: {len(continuous_periods) if len(sorted_periods) > 1 else len(sorted_periods)}개월의 데이터 입력")
            except Exception as e:
                self.logger.error(f"월별진료지표 월별진료 테이블 자동 업데이트 중 오류: {str(e)}")

            return {
                "success": True,
                "msg": "도표 업데이트가 완료되었습니다.",
                "detail": {
                    "patients": {"msg": f"회원 데이터가 {new_patients_sheet_name}에 복사되었습니다."},
                    "payment": {"msg": f"진료 데이터가 {new_payment_sheet_name}에 복사되었습니다."},
                    "formulas": {"msg": f"{updated_formulas}개의 수식이 업데이트되었습니다."}
                }
            }
        except Exception as e:
            self.logger.error(f"도표 업데이트 중 오류 발생: {str(e)}")
            return {"success": False, "msg": f"도표 업데이트 중 오류가 발생했습니다: {str(e)}"}

if __name__ == "__main__":
    backend = ExcelBackend()
    result = backend.run_table_update("회원-sales.xlsx", "Patients.csv", "PaymentItems.csv")
    print(result) 
